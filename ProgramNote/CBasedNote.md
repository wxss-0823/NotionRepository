# C++/C#/Java学习笔记

## 第一部分  C++笔记

### 实例

#### 俄罗斯方块实例

1. Javid9 C++ 游戏示例

   1. Teris Game

      核心问题：如何表示俄罗斯方块的旋转。

      思路：创建一个4*4的字符串，存放16位的字符描述物体的形状；对于索引可由x，y确定。

      | y/x  |  0   |  1   |  2   |  3   |
      | :--: | :--: | :--: | :--: | :--: |
      |  0   |  0   |  1   |  2   |  3   |
      |  1   |  4   |  5   |  6   |  7   |
      |  2   |  8   |  9   |  10  |  11  |
      |  3   |  12  |  13  |  14  |  15  |

      进行旋转操作时，不改变字符串，只改变x，y对字符串的索引方式。例如：字符串描述在索引为10的地方存在一个物体“X”，此时（x，y）=（2，2）；表示在最终的画布上（2，2）的位置存在一个物体；若进行顺时针旋转90°，表示在最终的画布上（1，2）的位置存在一个物体，即完成了旋转的操作。问题在于如何实现从（2，2）到（1，2）的变化。由于索引是不变的，那么无论如何旋转，当索引为10是，字符串总对应“X”，变化的仅仅是x，y与索引的对应关系。

      重要之处在于，我们关注的总是x，y的值，而不关心字符串在何处为“X”，如何找到不同旋转时的值是关键，因此通过不同状态下的映射公式，遍历就可以得知字符串为“X”时对应的x，y，即知道了应该画图形的位置。

## 第二部分  C#笔记

### 基础语法

#### 1.  数据类型

1. 值类型(Value types)

   [C#2010中可用的值类型](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/value-types#built-in-value-types)

2. 引用类型(Reference types)

   引用类型的变量存储对其数据（对象）的引用，而值类型的变量直接包含其数据。 对于引用类型，两种变量可引用同一对象；因此，对一个变量执行的操作会影响另一个变量所引用的对象。

   [引用类型参考](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/reference-types)

3. 指针类型(Pointer types)

   [不安全代码、指针类型和函数指针](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/unsafe-code#c-language-specification)

4. 修饰符
   - [访问修饰符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/access-modifiers)
   - [其他修饰符](https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/)

#### 2.  类型转换

1. 隐式转换

   从小范围到大范围，不丢失精度。

2. 显示转换

   可能丢失精度。

#### 3.   常量与变量

1. 实例无法访问类的成员常量，只能使用类名访问；

2. 字符串常量可以使用"\\"来转义，例如"\\n"，"\\t"

   可以使用两个"\\\\"来表示本来的"\\"，也可以使用@在字符串首部，表示字符串内不含转义字符。

#### 4.   运算符

1. 自加与自减运算的计算顺序

   ```c#
   c = a++;	//先将a的值赋给c，再对a进行自加运算
   c = ++a;	//先将a进行自加运算，再将值赋给c
   c = a--;
   c = --a;
   ```

2. 逻辑运算符与位运算符

   | 逻辑运算符 |  位运算符   |   位运算符   |
   | :--------: | :---------: | :----------: |
   |   &&(与)   |  &(按位与)  | ^(按位异或)  |
   |  \|\|(或)  | \|(按位或)  | <<(按位左移) |
   |   !(非)    | ~(按位取反) | >>(按位右移) |

3. 其他运算符

   |  运算符  |                 描述                  |
   | :------: | :-----------------------------------: |
   | sizeof() |    返回数据类型的大小：sizeof(int)    |
   | typrof() |            返回class的类型            |
   |    &     |                取地址                 |
   |    *     | 变量的指针：变量存放地址，*变量指向值 |
   |   ? :    | 条件表达式：满足第一个，不满足第二个  |
   |    is    |        判断对象是否为某一类型         |
   |    as    | 强制转换，即使转换失败也不会抛出异常  |

#### 5.  条件和循环

1. swich条件

   - **switch** 语句中的 **expression** 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
   - case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量。
   - 不允许从一个case继续执行到下一个，需要break结束。
   - 空case可以不适用break。
   - 可选一个default，当所有case都为False，执行default语句，也需要包含break。

   ```c#
   switch(expression){
       case constant-expression  :
          statement(s);
          break; 
       case constant-expression  :
          statement(s);
          break; 
     
       /* 您可以有任意数量的 case 语句 */
       default : /* 可选的 */
          statement(s);
          break; 
   }
   ```

2. for/foreach循环

   - **init** 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。
   - 接下来，会判断 **condition**。如果为真，则执行循环主体。如果为假，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。
   - 在执行完 for 循环主体后，控制流会跳回上面的 **increment** 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。

   ```c#
   for ( init; condition; increment )
   {
      statement(s);
   }// 写作for (; ; )，表示无限循环
   
   foreach (var item in collection)
   {
       // 循环
   }
   ```

#### 6.  C#的封装

C# 封装根据具体的需要，设置使用者的访问权限，并通过**访问修饰符**来实现。

- public：所有对象都可以访问；（不同命名空间的也可以）
- private：对象本身在对象内部可以访问；
- protected：只有该类对象及其子类对象可以访问
- internal：同一个程序集的对象可以访问；（只能同一命名空间）
- protected internal：访问限于当前程序集或派生自包含类的类型。（不同命名空间同一类）

#### 7.  C#的方法

1. 调用方法

   - 同一类内部调用
   - 不同类外部调用
   - 自我调用：递归

2. 参数传递

   - 值参数

     实参和形参使用的是两个不同内存中的值，保证实参数据安全。

   - 引用参数

     这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参。

   - 输出参数

     这种方法可以返回多个值，也可以为无初始值的变量返回值。

#### 8.  C#的可空类型（Nullable）

- 单问号 ? 
  用于对 **int、double、bool** 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 Nullable 类型的。

- 双问号 ??

  用于判断一个变量在为 null 的时候返回一个指定的值。

```c#
num3 = num1 ?? 5.34;      // num1 如果为空值则返回 5.34 否则返回num1
```

#### 9.  数组

1. 初始化数组

   数组是一个**引用**类型，需要用new创建数组实例。

#### 10.  字符串

1. 创建 String 对象

   使用以下方法之一来创建 string 对象：

   - 通过给 String 变量指定一个字符串

   - 通过使用 String 类构造函数

   - 通过使用字符串串联运算符（ + ）

   - 通过检索属性或调用一个返回字符串的方法

   - 通过格式化方法来转换一个值或对象为它的字符串表示形式


2. [String类的方法](https://www.runoob.com/csharp/csharp-string.html)

#### 11.  C#结构体

##### 特点

- 结构可带有方法、字段、索引、属性、运算符方法和事件。
- 结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。
- 与类不同，结构不能继承其他的结构或类。
- 结构不能作为其他结构或类的基础结构。
- 结构可实现一个或多个接口。
- 结构成员不能指定为 abstract、virtual 或 protected。
- 当您使用 **New** 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。
- 如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。

##### 类 vs 结构

- 类是引用类型，结构是值类型。
- 结构不支持继承。
- 结构不能声明默认的构造函数。

#### 12.  C#枚举

​	枚举是一组命名整型常量。枚举类型是使用 **enum** 关键字声明的。C# 枚举是值类型。换句话说，枚举包含自己的值，且不能继承或传递继承。

```c#
enum <enum_name>
{ 
    enumeration list 
};
```

#### 13.  C#类

1. 类的构造函数

   ​	类的 **构造函数** 是类的一个特殊的成员函数，当创建类的新对象时执行。构造函数的名称与类的名称完全相同，它没有任何返回类型。

   ​	**默认的构造函数**没有任何参数。但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做**参数化构造函数**。这种技术可以帮助你在创建对象的同时给对象赋初始值。

2. 类的析构函数

```C#
~Line()
{
	Console.WriteLine("对象以删除")
}
```

3. C#类的静态成员

   ​	我们可以使用 **static** 关键字把类成员定义为静态的。当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。

   ​	关键字 **static** 意味着类中只有一个该成员的实例。静态变量用于定义常量，因为它们的值可以通过直接调用类而不需要创建类的实例来获取。静态变量可在成员函数或类的定义外部进行初始化。你也可以在类的定义内部初始化静态变量。

   ​	你也可以把一个**成员函数**声明为 **static**。这样的函数只能访问静态变量。静态函数在对象被创建之前就已经存在。访问静态函数要用类名访问，不能用实例名访问。

#### 14.  继承

​	继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。

​	当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的**基类**，这个新的类被称为**派生类**。

1.  基类的初始化

   ​	派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。您可以在成员初始化列表中进行父类的初始化。

2. 多态继承

   ​	多重继承指的是一个类别可以同时从多于一个父类继承行为与特征的功能。与单一继承相对，单一继承指一个类别只可以继承自一个父类。**C# 不支持多重继承**。但是，您可以使用**接口**来实现多重继承。

#### 15.  C#多态性

​	多态是同一个行为具有多个不同表现形式或形态的能力。

​	**多态性**意味着有多重形式。在面向对象编程范式中，多态性往往表现为"一个接口，多个功能"。

​	多态性可以是静态的或动态的。在**静态多态性**中，函数的响应是在编译时发生的。在**动态多态性**中，函数的响应是在运行时发生的。

##### 静态多态性

1. 函数重载

   ​	同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。不同重载只有返回类型不同的函数声明。	

2. 运算符重载


##### 动态多态性

1. 抽象类

​	C# 使用关键字 **abstract** 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。**抽象类**包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。

- 不能创建一个抽象类的实例。
- 不能在一个抽象类外部声明一个抽象方法。
- 通过在类定义前面放置关键字 **sealed**，可以将类声明为**密封类**。当一个类被声明为 **sealed** 时，它不能被继承。抽象类不能被声明为 sealed。

2. 虚方法

​	当有一个定义在**常规类**中的函数需要在继承类中实现时，可以使用**虚方法**。虚方法是使用关键字 **virtual** 声明的。虚方法可以在不同的继承类中有不同的实现。对虚方法的调用是在运行时发生的。

##### 重载、重写、覆写

1. 重载(overload)：同一类同一方法的不同实现。
2. 重写(override)：子类对父类方法的重写，父类有**abstract**子类必有**override**，父类有**virtual**子类有**override**或者**overload。**
3. 覆写(overwrite)：用**new**实现，在子类中用关键字**new**修饰定义的与父类同名的方法，不会改变父类方法的功能。

#### 16.  C#运算符重载

​	为某些特殊的对象定义新的计算方式。定义方式如下：

```c#
public static Box operator+ (Box b, Box c)
{
   Box box = new Box();
   box.length = b.length + c.length;
   box.breadth = b.breadth + c.breadth;
   box.height = b.height + c.height;
   return box;
}
```

​	Box对象的加法运算被重载。注意：Box对象直接无法相加，只有重载后，才可以进行加运算，返回一个Box对象。

​	[可重载和不可重载的运算符](https://www.runoob.com/csharp/csharp-operator-overloading.html)

- 在将一个复杂类转化为字符串时，可以通过覆写**ToString**方法，通过String.Format()自定义转换形式。

#### 17.  C#接口(Interface)

​	接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。接口使得实现接口的类或结构在形式上保持一致。接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。

​	抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。

##### 定义接口

```c#
interface IMyInterface
{
    void MethodToImplement();
}
```

##### 接口继承

​	接口可以多重继承，最后要实现所有继承过程中的接口函数。

#### 18.  C#命名空间

​	**命名空间**的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。

##### 定义命名空间

```c#
namespace namespace_name
{
   // 代码声明
}
```

​	为了调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面，

##### using关键字

​	**using** 关键字表明程序使用的是给定命名空间中的名称。多个命名空间可以分别用using添加，但是要保证类名存在区别，否则调用方法时仍然无法区分。

##### 嵌套命名空间

​	命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间。您可以使用点（.）运算符访问嵌套的命名空间的成员。

#### 19.  C#预处理器指令

​	[C#预处理器指令列表](https://www.runoob.com/csharp/csharp-preprocessor-directives.html)

##### #define 预处理器

​	创建符号变量，定义一个符号。

##### #if 条件指令

​	判断符号是否由#define定义，是则返回true。

```c#
#if
#else
#endif	// 不要忘记最后的endif
```

#### 20.  正则表达式

​	正则表达式是一种快速匹配输入文本的模式，模式由一个或多个字符、运算符和结构构成。

​	[正则表达式的模式对应](https://www.runoob.com/csharp/csharp-regular-expressions.html)

​	[正则表达式在线测试工具](https://c.runoob.com/front-end/854/)

- 字符转义

| 转义字符 |                             描述                             |
| :------: | :----------------------------------------------------------: |
|    \a    |                  与报警（bell）符\u0007匹配                  |
|    \b    |                    在字符类中与\u0008匹配                    |
|    \t    |                      与制表符\u0009匹配                      |
|    \     | 在后面带有不识别的转义字符时，与该字符匹配<br />（\\\\* == *） |

- 字符类
- 定位点
- 分组构造

​	分组构造描述了正则表达式的子表达式，通常用于捕获输入字符串的子字符串。

- 限定符

​	限定符指定在输入字符串中必须存在上一个元素（可以是字符、组或字符类）的多少个实例才能出现匹配项。 

- 反向作用构造

​	反向引用允许在同一正则表达式中随后标识以前匹配的子表达式。

| 反向引用构造 |               描述               |         模式          |
| :----------: | :------------------------------: | :-------------------: |
|   \number    |  反向引用。匹配编号子表达式的值  |        (\w)\1         |
|  \k\<name>   | 命名反向引用。匹配命名表达式的值 | (?\<char>\w)\k\<char> |

​	解释：(\w)\1的作用是，1.将字符串任意字符匹配；2.()意为将匹配结果放入命名空间#1；3.\1意为引用编号为#1的表达式。最终获得的效果是将字符串自我匹配，判断是否存在重复的字母。

- 备用构造

​	备用构造用于修改正则表达式以启用 either/or 匹配。

- 替换

​	替换是替换模式中使用的正则表达式。

- 杂项构造
  - 不区分大小写模式
  - 内联注释
  - 行尾注释

#### 21.  异常处理

​	建立于四个关键字：**try**, **catch**, **finally**, **throw**

- **try**：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。
- **catch**：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。
- **finally**：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。
- **throw**：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。

##### 语法

```c#
try
{
   // 引起异常的语句
}
catch( ExceptionName e1 )
{
   // 错误处理代码
   Throw e1	// 当异常直接或间接派生自System.Exception类
}
catch( ExceptionName e2 )
{
   // 错误处理代码
}
finally
{
   // 要执行的语句
}
```

#### 22.  C#文件的输入输出

##### FileStream类

​	System.IO 命名空间中的 **FileStream** 类有助于文件的读写与关闭。该类派生自抽象类 Stream。

```C#
FileStream <object_name> = new FileStream( <file_name>,
<FileMode Enumerator>, <FileAccess Enumerator>, <FileShare Enumerator>);
```

##### 文本文件的读写

​	**StreamReader** 和 **StreamWriter** 类有助于完成文本文件的读写。

- [**StreamReader**类](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.streamreader?view=net-8.0#methods)：继承自抽象基类 TextReader，表示阅读器读取一系列字符。
- [**StreamWriter**类](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.streamwriter?view=net-8.0#methods)：继承自抽象类 TextWriter，表示编写器写入一系列字符。

##### 二进制文件的读写

​	**BinaryReader** 和 **BinaryWriter** 类有助于完成二进制文件的读写。

- [**BinaryReader** 类](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.binaryreader?view=net-8.0#methods)：用于从文件读取二进制数据。一个 **BinaryReader** 对象通过向它的构造函数传递 **FileStream** 对象而被创建。
- [**BinaryWriter** 类](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.binarywriter?view=net-8.0#methods)：用于向文件写入二进制数据。一个 **BinaryWriter** 对象通过向它的构造函数传递 **FileStream** 对象而被创建。

##### Windows文件系统的操作

​	能够浏览并定位 Windows 文件和目录。

- [**DirectoryInfo** 类](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.directoryinfo?view=net-8.0#methods)：派生自 **FileSystemInfo** 类。它提供了各种用于创建、移动、浏览目录和子目录的方法。该类不能被继承。
- [**FileInfo** 类](https://learn.microsoft.com/zh-cn/dotnet/api/system.io.fileinfo?view=net-8.0#methods)：派生自 **FileSystemInfo** 类。它提供了用于创建、复制、删除、移动、打开文件的属性和方法，且有助于 FileStream 对象的创建。该类不能被继承。

### 进阶语法

#### 1.  C#特性（Attribute）

​	用于在运行时传递程序中各种元素（比如类、方法、结构、枚举、组件等）的行为信息的声明性标签。您可以通过使用特性向程序添加声明性信息。一个声明性标签是通过放置在它所应用的元素前面的方括号（[ ]）来描述的。特性（Attribute）用于添加元数据，如编译器指令和注释、描述、方法、类等其他信息。.Net 框架提供了两种类型的特性：**预定义**特性和**自定义**特性。

##### 规定特性

```c#
[attribute(positional_parameters, name_parameter = value, ...)]
element
```

##### 预定义特性

- AttributeUsage：描述了如何使用一个自定义特性类。它规定了特性可应用到的项目的类型。

  ```
  [AttributeUsage(
     validon,
     AllowMultiple=allowmultiple,
     Inherited=inherited
  )]
  ```

  - 参数 validon 规定特性可被放置的语言元素。它是枚举器 *AttributeTargets* 的值的组合。默认值是 *AttributeTargets.All*。
  - 参数 *allowmultiple*（可选的）为该特性的 *AllowMultiple* 属性（property）提供一个布尔值。如果为 true，则该特性是多用的。默认值是 false（单用的）。
  - 参数 *inherited*（可选的）为该特性的 *Inherited* 属性（property）提供一个布尔值。如果为 true，则该特性可被派生类继承。默认值是 false（不被继承）。

- Conditional：标记了一个条件方法，其执行依赖于指定的预处理标识符。它会引起方法调用的条件编译，取决于指定的值，比如 **Debug** 或 **Trace**。

- Obsolete：标记了不应被使用的程序实体。它可以让您通知编译器丢弃某个特定的目标元素。例如，当一个新方法被用在一个类中，但是您仍然想要保持类中的旧方法，您可以通过显示一个应该使用新方法，而不是旧方法的消息，来把它标记为 obsolete（过时的）。

- ```c#
  [Obsolete(
     message,
     iserror
  )]
  ```

  - 参数 *message*，是一个字符串，描述项目为什么过时以及该替代使用什么。

  - 参数 *iserror*，是一个布尔值。如果该值为 true，编译器应把该项目的使用当作一个错误。默认值是 false（编译器生成一个警告）。

##### 自定义特性

四个步骤：

- 声明自定义特性：应派生自**System.Attribute**且用**AttribueUsage**声明该特性的用途。
- 构建自定义特性
- 在目标程序元素上应用自定义特性
- 通过反射访问特性

#### 2.  C#反射（Reflection）

​	反射指程序可以访问、检测和修改它本身状态或行为的一种能力。

​	程序集包含模块，而模块包含类型，类型又包含成员。反射则提供了封装程序集、模块和类型的对象。

​	可以使用反射动态地创建类型的实例，将类型绑定到现有对象，或从现有对象中获取类型。然后，可以调用类型的方法或访问其字段和属性。

##### 优缺点

优点：

- 1、反射提高了程序的灵活性和扩展性。
- 2、降低耦合性，提高自适应能力。
- 3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。

缺点：

- 1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。
- 2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。

##### 用途

- 它允许在运行时查看特性（attribute）信息。
- 它允许审查集合中的各种类型，以及实例化这些类型。
- 它允许延迟绑定的方法和属性（property）。
- 它允许在运行时创建新类型，然后使用这些类型执行一些任务。

##### 异常处理

```c#
// 定义一个Type类的变量，用于保存typeof返回的类的类型
Type type = typeof(<class_name>);
// 使用GetMethods()，返回type的全部方法
MethodsInfo m = type.GetMethods();
// 此时的 m 变量不仅有 <class_name> 的方法，还包含 Type 类的方法
// 可以用 GetMethods(BindingFlags) 界限返回的范围
```

#### 3.  C#属性（Property）

​	**属性（Property）** 是类（class）、结构（structure）和接口（interface）的命名（named）成员。类或结构中的成员变量或方法称为 **域（Field）**。属性（Property）是域（Field）的扩展，且可使用相同的语法来访问。它们使用 **访问器（accessors）** 让私有域的值可被读写或操作。

​	属性（Property）不会确定存储位置。相反，它们具有可读写或计算它们值的 **访问器（accessors）**。

##### 访问器

​	属性（Property）的**访问器（accessor）**包含有助于获取（读取或计算）或设置（写入）属性的可执行语句。访问器（accessor）声明可包含一个 get 访问器、一个 set 访问器，或者同时包含二者。

##### 抽象属性

​	抽象类可拥有抽象属性，这些属性应在派生类中实现。

#### 4.  C#索引器（Indexer）

​	**索引器（Indexer）** 允许一个对象可以像数组一样使用下标的方式来访问。当您为类定义一个索引器时，该类的行为就会像一个 **虚拟数组（virtual array）** 一样。您可以使用数组访问运算符 **[ ]** 来访问该类的的成员。

##### 语法

```c#
element-type this[int index]	// 可以是多种类型，int非必要
{
   // get 访问器
   get
   {
      // 返回 index 指定的值
   }

   // set 访问器
   set
   {
      // 设置 index 指定的值
   }
}
```

##### 用途

​	索引器的行为的声明在某种程度上类似于属性(property)。就像属性(property)，您可使用 **get** 和 **set** 访问器来定义索引器。但是，属性返回或设置一个特定的数据成员，而索引器返回或设置对象实例的一个特定值。换句话说，它把实例数据分为更小的部分，并索引每个部分，获取或设置每个部分。

​	定义一个属性(property)包括提供属性名称。索引器定义的时候不带有名称，但带有 **this** 关键字，它指向对象实例。

#### 5.  C#委托（Delegate）

##### 声明

​	委托方法声明了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。

```c#
delegate <return type> <delegate-name> <parameter list>
```

##### 实例化委托

​	使用**new**关键字创建，且与一个特定的方法有关。当创建委托时，传递到**new**语句的参数就像方法调用一样书写，但是不带有参数

```c#
public delegate void printString(string s);
...
printString ps1 = new printString(WriteToScreen);
```

##### 委托的多播

​	委托对象可使用 "+" 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。"-" 运算符可用于从合并的委托中移除组件委托。

​	使用委托的这个有用的特点，您可以创建一个委托被调用时要调用的方法的调用列表。这被称为委托的 **多播（multicasting）**，也叫组播。

​	相当于将两个方法传入同样的参数，按照顺序依次执行。两个方法必须输入输出类型都相同，且输出类型符合委托的输入类型。

#### 6.  C#事件（Event）

​	基本上说是一个用户操作，如按键、点击、鼠标移动等等，或者是一些提示信息，如系统生成的通知。应用程序需要在事件发生时响应事件。

##### 委托和事件（通过事件使用委托）

​	事件在类中声明且生成，且通过使用同一个类或其他类中的委托与事件处理程序关联。包含事件的类用于发布事件。这被称为 **发布器（publisher）** 类。其他接受该事件的类被称为 **订阅器（subscriber）** 类。事件使用 **发布-订阅（publisher-subscriber）** 模型。

- **发布器（publisher）** 

​	是一个包含事件和委托定义的对象。事件和委托之间的联系也定义在这个对象中。发布器(publisher)类的对象调用这个事件，并通知其他的对象。

- **订阅器（subscriber）** 

​	是一个接受事件并提供事件处理程序的对象。在发布器(publisher)类中的委托调用订阅器(subscriber)类中的方法（事件处理程序）。

##### 声明事件

- 类的内部声明事件，首先声明该事件的委托类型

  ```c#
  public delegate void BoilerLogHandler(string status);
  ```

- 然后声明事件本身，使用**event**关键字。

  ```c#
  // 基于上面的委托定义事件
  public event BoilerLogHandler BoilerEventLog;
  ```

##### 执行过程

- 实例化对象
- 为定义的事件添加具体的委托，并挂载方法
- 执行对象的某一方法时，调用到事件，上一步已经为事件添加了方法，调用时，会调用委托，再调用方法。

```c#
e.ChangeNum += new EventTest.NumManipulationHandler( v.printf ); /* 注册 */
```

为事件**ChangeNum**注册一个**NumManipulationHandler**的委托，委托的目标是订阅器的**printf()**方法。

#### 7.  C#集合（Collection）

​	集合（Collection）类是专门用于数据存储和检索的类。这些类提供了对栈（stack）、队列（queue）、列表（list）和哈希表（hash table）的支持。大多数集合类实现了相同的接口。

​	集合（Collection）类服务于不同的目的，如为元素动态分配内存，基于索引访问列表项等等。这些类创建 Object 类的对象的集合。

​	[**各种集合类和它们的用法**](https://www.runoob.com/csharp/csharp-collection.html)

#### 8.  C#泛型（Generic）

​	允许您延迟编写类或方法中的编程元素的数据类型的规范，直到实际在程序中使用它的时候。换句话说，泛型允许您编写一个可以与任何数据类型一起工作的类或方法。

​	可以通过数据类型的替代参数编写类或方法的规范。当编译器遇到类的构造函数或方法的函数调用时，它会生成代码来处理指定的数据类型。

##### 泛型的特性

- 它有助于您最大限度地重用代码、保护类型的安全以及提高性能。
- 您可以创建泛型集合类。.NET 框架类库在 *System.Collections.Generic* 命名空间中包含了一些新的泛型集合类。您可以使用这些泛型集合类来替代 *System.Collections* 中的集合类。
- 您可以创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。
- 您可以对泛型类进行约束以访问特定数据类型的方法。
- 关于泛型数据类型中使用的类型的信息可在运行时通过使用反射获取。

##### 泛型方法

```c#
 static void Swap<T>(ref T lhs, ref T rhs)
```

##### 泛型委托

```c#
delegate T NumberChanger<T>(T n);
```

#### 9.  C#匿名方法

​	**匿名方法（Anonymous methods）** 提供了一种传递代码块作为委托参数的技术。匿名方法是没有名称只有主体的方法。

​	在匿名方法中您不需要指定返回类型，它是从方法主体内的 return 语句推断的。

##### 语法

```c#
delegate void NumberChanger(int n);
...
NumberChanger nc = delegate(int x)
{
    Console.WriteLine("Anonymous Method: {0}", x);
};
```

​	委托可以通过匿名方法调用，也可以通过命名方法调用，即，通过向委托对象传递方法参数。

**注意:** 匿名方法的主体后面需要一个 ”**;**“。

#### C#不安全代码

​	当一个代码块使用 **unsafe** 修饰符标记时，C# 允许在函数中使用指针变量。**不安全代码**或非托管代码是指使用了**指针**变量的代码块。

##### 指针变量

| 实例        | 描述                             |
| :---------- | :------------------------------- |
| `int* p`    | `p` 是指向整数的指针。           |
| `double* p` | `p` 是指向双精度数的指针。       |
| `float* p`  | `p` 是指向浮点数的指针。         |
| `int** p`   | `p` 是指向整数的指针的指针。     |
| `int*[] p`  | `p` 是指向整数的指针的一维数组。 |
| `char* p`   | `p` 是指向字符的指针。           |
| `void* p`   | `p` 是指向未知类型的指针。       |

##### 使用指针检索数据值

​	使用**ToString**方法检索存储在指针变量所引用的位置的数据。

```c#
 int var = 10;
 int* p = &var;
 p->ToString()
```

##### 传递指针作为方法的参数

​	可以向方法传递指针变量作为方法的参数。

##### 使用指针访问数组元素

​	数组名称和一个指向与数组数据具有相同数据类型的指针是不同的变量类型。数组地址在内存中是固定的，但是指针不是，因此索引时，随机被存放的指针可能引起麻烦，可以使用**fixed**关键字固定指针。

​	指针默认指向数组第一个元素，即指针**ptr**默认等于第一个元素的地址。

#### C#多线程

​	**线程** 被定义为程序的执行路径。每个线程都定义了一个独特的控制流。如果您的应用程序涉及到复杂的和耗时的操作，那么设置不同的线程执行路径往往是有益的，每个线程执行特定的工作。

​	线程是**轻量级进程**。一个使用线程的常见实例是现代操作系统中并行编程的实现。使用线程节省了 CPU 周期的浪费，同时提高了应用程序的效率。

##### 线程生命周期

​	线程生命周期开始于 System.Threading.Thread 类的对象被创建时，结束于线程被终止或完成执行时。

- **未启动状态**：当线程实例被创建但 Start 方法未被调用时的状况。
- **就绪状态**：当线程准备好运行并等待 CPU 周期时的状况。
- 不可运行状态：
  - 已经调用 Sleep 方法
  - 已经调用 Wait 方法
  - 通过 I/O 操作阻塞
- **死亡状态**：当线程已完成执行或已中止时的状况。

##### 主线程

​	**System.Threading.Thread** 类用于线程的工作。它允许创建并访问多线程应用程序中的单个线程。进程中第一个被执行的线程称为**主线程**。

​	当 C# 程序开始执行时，主线程自动创建。使用 **Thread** 类创建的线程被主线程的子线程调用。您可以使用 Thread 类的 **CurrentThread** 属性访问线程。

##### Thread类常用的属性和方法

​	[常用的属性和方法](https://www.runoob.com/csharp/csharp-multithreading.html)

##### 创建线程

​	线程是通过扩展 Thread 类创建的。扩展的 Thread 类调用 **Start()** 方法来开始子线程的执行。

##### 管理线程

​	Thread 类提供了各种管理线程的方法。

##### 销毁线程

- `CancellationTokenSource`：

  - 手动取消：实例化source对象并执行`source.Cancel();`
  - 定时取消：`source.CancelAfter(<time>);`

- **（已过时）**Abort() 方法用于销毁线程。

  通过抛出 **threadabortexception** 在运行时中止线程。这个异常不能被捕获，如果有 *finally* 块，控制会被送至 *finally* 块。

### 语法问题

#### static类或static方法

- static类不可实例化
- static方法属于类固有，实例不占用新的内存

#### base关键字

- 用于子类继承父类的构造函数
