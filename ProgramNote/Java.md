## Java 笔记

### Java 基础教程

#### 1.  注释

##### 单行注释

以双斜杠 `//` 开始。

##### 多行注释

以 `/*` 开始，以 `*/` 结束。

##### 文档注释

以 `/**` 开始，以 `*/` 结束。

#### 2.  对象和类

##### 类的类型变量

- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
- **类变量**：类变量也声明在类中，方法体之外，但必须声明为 static 类型。

##### 构造方法

- 每个类都有构造方法。

- 构造方法的名称必须与类同名，一个类可以有多个构造方法。

##### 创建对象

- **声明**：声明一个对象，包括对象名称和对象类型。
- **实例化**：使用关键字 new 来创建一个对象。
- **初始化**：使用 new 创建对象时，会调用构造方法初始化对象。

##### 访问实例变量和方法

- 通过 `.` 运算符。

##### 源文件声明规则

- 一个源文件中只能有一个 public 类
- 一个源文件可以有多个非 public 类
- 源文件的名称应该和 public 类的类名保持一致。
- 如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。
- 如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。
- import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类声明不同的包。

##### Java 包

包主要用来对类和接口进行分类。

##### import 语句

import 语句用来提供一个合理的路径，使得编译器可以找到某个类。

#### 3.  基础数据类型

##### 内置数据类型

**byte：**

- byte 数据类型是8位、有符号的，以二进制补码表示的整数；
- 最小值是 **-128（-2^7）**；
- 最大值是 **127（2^7-1）**；
- 默认值是 **0**；
- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一。

**short：**

- short 数据类型是 16 位、有符号的以二进制补码表示的整数
- 最小值是 **-32768（-2^15）**；
- 最大值是 **32767（2^15 - 1）**；
- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
- 默认值是 **0**。

**int：**

- int 数据类型是32位、有符号的以二进制补码表示的整数；
- 最小值是 **-2,147,483,648（-2^31）**；
- 最大值是 **2,147,483,647（2^31 - 1）**；
- 一般地整型变量默认为 int 类型；
- 默认值是 **0** 。

**long：**

- long 数据类型是 64 位、有符号的以二进制补码表示的整数；
- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；
- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；
- 这种类型主要使用在需要比较大整数的系统上；
- 默认值是 **0L**。

**float：**

- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；
- float 在储存大型浮点数组的时候可节省内存空间；
- 默认值是 **0.0f**；
- 浮点数不能用来表示精确的值，如货币。

**double：**

- double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；
- 浮点数的默认类型为 double 类型；
- double类型同样不能表示精确的值，如货币；
- 默认值是 **0.0d**。

**boolean：**

- boolean数据类型表示一位的信息；
- 只有两个取值：true 和 false；
- 这种类型只作为一种标志来记录 true/false 情况；
- 默认值是 **false**。

**char：**

- char 类型是一个单一的 16 位 Unicode 字符；
- 最小值是 **\u0000**（十进制等效值为 0）；
- 最大值是 **\uffff**（即为 65535）；
- char 数据类型可以储存任何字符。

##### 引用类型

- 引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型。
- 对象、数组都是引用数据类型。
- 所有引用类型的默认值都是null。
- 一个引用变量可以用来引用任何与之兼容的类型。

##### 常量

常量在程序运行时是不能被修改的。

##### 自动类型转换

**整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。**

转换从低级到高级。

```java
byte,short,char—> int —> long—> float —> double 
```

数据类型转换必须满足如下规则：

- 不能对boolean类型进行类型转换。
- 不能把对象类型转换成不相关类的对象。
- 在把容量大的类型转换为容量小的类型时必须使用强制类型转换。
- 转换过程中可能导致溢出或损失精度。
- 浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。

###### 自动类型转换

必须满足转换前的数据类型的位数要低于转换后的数据类型。

###### 强制类型转换

- 条件是转换的数据类型必须是兼容的。

- 格式：(type)value type是要强制类型转换后的数据类型。

###### 隐含强制类型转换

- 整数的默认类型是 int。
- 小数默认是 double 类型浮点型，在定义 float 类型时必须在数字后面跟上 F 或者 f。

#### 4.  变量类型

##### 变量声明

```java
type identifier [ = value][, identifier [= value] ...] ;
```

##### 变量类型

- **局部变量（Local Variables）：**局部变量是在方法、构造函数或块内部声明的变量，它们在声明的方法、构造函数或块执行结束后被销毁，局部变量在声明时需要初始化，否则会导致编译错误。

  ```java
  public void exampleMethod() {
      int localVar = 10; // 局部变量
      // ...
  }
  ```

- **实例变量（Instance Variables）：**实例变量是在类中声明，但在方法、构造函数或块之外，它们属于类的实例，每个类的实例都有自己的副本，如果不明确初始化，实例变量会被赋予默认值（数值类型为0，boolean类型为false，对象引用类型为null）。

  ```java
  public class ExampleClass {
      int instanceVar; // 实例变量
  }
  ```

- **静态变量或类变量（Class Variables）：**类变量是在类中用 static 关键字声明的变量，它们属于类而不是实例，所有该类的实例共享同一个类变量的值，类变量在类加载时被初始化，而且只初始化一次。

  ```java
  public class ExampleClass {
      static int classVar; // 类变量
  }
  ```

- **参数变量（Parameters）：**参数是方法或构造函数声明中的变量，用于接收调用该方法或构造函数时传递的值，参数变量的作用域只限于方法内部。

  ```java
  public void exampleMethod(int parameterVar) {
      // 参数变量
      // ...
  }
  ```

##### 参数变量

- **值传递：**在方法调用时，传递的是实际参数的值的副本。当参数变量被赋予新的值时，只会修改副本的值，不会影响原始值。Java 中的基本数据类型都采用值传递方式传递参数变量的值。
- **引用传递：**在方法调用时，传递的是实际参数的引用（即内存地址）。当参数变量被赋予新的值时，会修改原始值的内容。Java 中的对象类型采用引用传递方式传递参数变量的值。

##### 局部变量

- 局部变量必须在使用前声明，并且不能被访问修饰符修饰，因为它们的作用域已经被限制在了声明它们的方法、代码块或构造函数中。
- 局部变量只在声明它的方法、构造方法或者语句块中可见，不能被其他方法或代码块访问。
- 局部变量是在栈上分配的。
- 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。

##### 成员变量（实例变量）

- 成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。
- 成员变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：**ObjectReference.VariableName**。

##### 类变量（静态变量）

###### 定义方式

静态变量的定义方式是在类中使用 **static** 关键字修饰变量，通常也称为类变量。

###### 访问方式

由于静态变量是与类相关的，因此可以通过类名来访问静态变量，也可以通过实例名来访问静态变量。

###### 生命周期

静态变量的生命周期与程序的生命周期一样长，即它们在类加载时被创建，在整个程序运行期间都存在，直到程序结束才会被销毁。 因此，静态变量可以用来存储整个程序都需要使用的数据，如配置信息、全局变量等。

###### 初始化时机

静态变量在类加载时被初始化，其初始化顺序与定义顺序有关。

##### 静态变量的线程安全性

当多个线程同时访问一个包含静态变量的类时，需要考虑其线程安全性。

##### 静态变量的命名规范

- **使用驼峰命名法：** 静态变量的命名应该使用驼峰命名法，即首字母小写，后续每个单词的首字母大写。 例如：。`myStaticVariable`
- **全大写字母：** 静态变量通常使用全大写字母，单词之间用下划线分隔。 这被称为"大写蛇形命名法"（Upper Snake Case）。 例如：。`MY_STATIC_VARIABLE`
- **描述性：** 变量名应该是有意义的，能够清晰地表达该变量的用途。 避免使用单个字符或不具有明确含义的缩写。
- **避免使用缩写：** 尽量避免使用缩写，以提高代码的可读性。 如果使用缩写是必要的，确保广泛理解，并在注释中进行解释。

##### 静态变量的使用场景

- 存储全局状态或配置信息
- 计数器或统计信息
- 缓存数据或共享资源
- 工具类的常量或方法
- 单例模式中的实例变量

#### 5.  变量命名规则

##### 局部变量

- 使用驼峰命名法，应该以小写字母开头。

##### 实例变量（成员变量）

- 使用驼峰命名法，应该以小写字母开头。

##### 静态变量（类变量）

- 使用驼峰命名法，应该以小写字母开头。
- 通常也可以使用大写蛇形命名法，全大写字母，单词之间用下划线分隔。

##### 常量

- 使用全大写字母，单词之间用下划线分隔。
- 常量通常使用 `final` 修饰。

##### 参数

- 使用驼峰命名法，应该以小写字母开头。

##### 类名

- 使用驼峰命名法，应该以大写字母开头。

#### 6.  修饰符

##### 访问控制修饰符

- **default** (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。
- **private** : 在同一类内可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**
- **public** : 对所有类可见。使用对象：类、接口、变量、方法
- **protected** : 对同一包内的类和所有子类可见。使用对象：变量、方法。 **注意：不能修饰类（外部类）**。

###### 默认访问修饰符-不使用任何关键字

- 如果在类、变量、方法或构造函数的定义中没有指定任何访问修饰符，那么它们就默认具有默认访问修饰符。

- 默认访问修饰符的访问级别是包级别（package-level），即只能被同一包中的其他类访问。

###### 私有访问修饰符-private

- 私有访问修饰符是最严格的访问级别，变量和构造方法只能被所属类访问，并且类和接口不能声明为 **private**。

- 声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。

- Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。

###### 公有访问修饰符-public

- 被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。

- 如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。

###### 受保护的访问修饰符-protected

- **子类与基类在同一包中**：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；
- **子类与基类不在同一包中**：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。

###### 访问控制和继承

- 父类中声明为 public 的方法在子类中也必须为 public。
- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。
- 父类中声明为 private 的方法，不能够被子类继承。

##### 非访问修饰符

###### static 修饰符

- **静态变量：**static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。
- **静态方法：**static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。

对类变量和方法的访问可以直接使用 **classname.variablename** 和 **classname.methodname** 的方式访问。

###### final 修饰符

- final 变量

  - 变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。

  - final 修饰符通常和 static 修饰符一起使用来创建类常量。

- final 方法

  - 父类中的 final 方法可以被子类继承，但是不能被子类重写。

  - 声明 final 方法的主要目的是防止该方法的内容被修改。

- final 类
  - final 类不能被继承，没有类能够继承 final 类的任何特性。

##### abstract 修饰符

###### 抽象类

- 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。

- 一个类不能同时被 abstract 和 final 修饰。
- 如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。

- 抽象类可以包含抽象方法和非抽象方法。

###### 抽象方法

- 抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。

- 抽象方法不能被声明成 final 和 static。

- 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。

- 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。

- 抽象方法的声明以分号结尾，例如：**public abstract sample();**。

##### synchronized 修饰符

- synchronized 关键字声明的方法同一时间只能被一个线程访问
- synchronized 修饰符可以应用于四个访问修饰符。

##### transient 修饰符

- 序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。

- 该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。

##### volatile 修饰符

- volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。
- 当成员变量发生变化时，会强制线程将变化值回写到共享内存。

#### 7.  运算符

- 算术运算符
- 关系运算符
- 位运算符
- 逻辑运算符
- 赋值运算符
- 其他运算符

#### 8.  循环结构 - for, while 及 do...while

##### while 循环

```java
while( 布尔表达式 ) {
    //循环内容 
}
```

只要布尔表达式为 true，循环就会一直执行下去。

##### do…while 循环

do…while 循环至少会执行一次。

```java
do {
       //代码语句
}while(布尔表达式);
```

**注意：**如果布尔表达式的值为 true，则语句块一直执行，直到布尔表达式的值为 false。

##### for循环

```java
for(初始化; 布尔表达式; 更新) {
    //代码语句 
}
```

- 最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。
- 然后，检测布尔表达式的值。如果为 true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。
- 执行一次循环后，更新循环控制变量。

##### 增强 for 循环

```java
for(声明语句 : 表达式) {
    //代码句子 
}
```

**声明语句：**声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。

**表达式：**表达式是要访问的数组名，或者是返回值为数组的方法。

##### break 关键字

- break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。

- break 跳出最里层的循环，并且继续执行该循环下面的语句。

##### continue 关键字

continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。

- 在 for 循环中，continue 语句使程序立即跳转到更新语句。

- 在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。

#### 9.  条件语句 - if...else

```java
if(布尔表达式) {
    //如果布尔表达式为true将执行的语句
}
```

##### if...else语句

```java
if(布尔表达式){
    //如果布尔表达式的值为true 
}
else{   
    //如果布尔表达式的值为false 
}
```

##### if...else if...else 语句

```java
if(布尔表达式 1){
    //如果布尔表达式 1的值为true执行代码 
}else if(布尔表达式 2){
    //如果布尔表达式 2的值为true执行代码 
}else if(布尔表达式 3){
    //如果布尔表达式 3的值为true执行代码 
}else {
    //如果以上布尔表达式都不为true执行代码 
}
```

##### 嵌套的 if…else 语句

```java
if(布尔表达式 1){
    ////如果布尔表达式 1的值为true执行代码   
    if(布尔表达式 2){
        ////如果布尔表达式 2的值为true执行代码   
    } 
}
```

#### 10.  switch case 语句

```java
switch(expression){
    case value :
       //语句
       break; //可选
    case value :
       //语句
       break; //可选
    //你可以有任意数量的case语句
    default : //可选
       //语句
}
```

#### 11.  Number & Math 类

##### Number 类

- Java 语言为每一个内置数据类型提供了对应的包装类。
- 所有的包装类**（Integer、Long、Byte、Double、Float、Short）**都是抽象类 Number 的子类。

##### Math 类

- Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。

#### 12.  Character 类

- Character 类用于对单个字符进行操作。

- Character 类在对象中包装一个基本类型 **char** 的值

#### 13.  String 类

##### 创建字符串

```java
String str = "Runoob";
String str2 = new String("Runoob");
```

##### 字符串长度

```java
str.length();
```

##### 链接字符串

```java
string1.concat(string2);
```

##### 创建格式化字符串

```java
String fs = String.format("...%d", intVar);
```

#### 14.  StringBuffer 和 StringBuilder 类

- 在使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象。

- StringBuilder 类和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。

- 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。

#### 15.  数组

数组可以作为函数的参数或者返回值。

##### 新建数组

```java
dataType[] arrayRefVar;   // 首选的方法：
```

```java
arrayRefVar = new dataType[arraySize];
```

##### 处理数组

数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者 For-Each 循环（增强型 for 循环）。

##### 多维数组

1. 直接为每一维分配空间：

```java
type[][] typeName = new type[typeLength1][typeLength2];
```

2. 从最高维开始，分别为每一维分配空间：

```java
// 声明是一个 2 行数组
String[][] s = new String[2][];
// 声明第 1 行有 2 个元素
s[0] = new String[2];
// 声明第 2 行有 3 个元素
s[1] = new String[3];
```

#### 16.  日期时间

java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。

- 第一个构造函数使用当前日期和时间来初始化对象。

```java
Date( )
```

- 第二个构造函数接收一个参数，该参数是从 1970 年 1 月 1 日起的毫秒数。

```java
Date(long millisec)
```

##### 日期比较

- 使用 getTime() 方法获取两个日期（自1970年1月1日经历的毫秒数值），然后比较这两个值。
- 使用方法 before()，after() 和 equals()。
- 使用 compareTo() 方法，它是由 Comparable 接口定义的，Date 类实现了这个接口。

##### 使用 SimpleDateFormat 格式化日期

- SimpleDateFormat 是一个以语言环境敏感的方式来格式化和分析日期的类。
- SimpleDateFormat 允许你选择任何用户自定义日期时间格式来运行。

##### 使用printf格式化日期

使用两个字母格式，它以 **%t** 开头并且以下面表格中的一个字母结尾。

| 转换符 | 说明                        | 示例                             |
| :----- | :-------------------------- | :------------------------------- |
| %tc    | 包括全部日期和时间信息      | 星期六 十月 27 14:21:20 CST 2007 |
| %tF    | "年-月-日"格式              | 2007-10-27                       |
| %tD    | "月/日/年"格式              | 10/27/07                         |
| %tr    | "HH:MM:SS PM"格式（12时制） | 02:25:51 下午                    |
| %tT    | "HH:MM:SS"格式（24时制）    | 14:28:16                         |
| %tR    | "HH:MM"格式（24时制）       | 14:28                            |

##### 解析字符串为时间

SimpleDateFormat 类的附加方法parse()，按照给定的格式化存储来解析字符串。

##### Java 休眠(sleep)

sleep() 使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用。目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。

##### Calendar类

###### 创建一个代表系统当前日期的Calendar对象

```java
Calendar c = Calendar.getInstance();//默认是当前日期
```

###### 创建一个指定日期的Calendar对象

使用Calendar类代表特定的时间，需要首先创建一个Calendar的对象，然后再设定该对象中的年月日参数来完成。

```java
//创建一个代表2009年6月12日的Calendar对象
Calendar c1 = Calendar.getInstance();
c1.set(2009, 6 - 1, 12);
```

###### Calendar类对象信息的设置

**Set 设置**

```java
// 设置年、月、日
public final void set(int year,int month,int date)
// 设置某一个参数，例如日
public void set(int field,int value)
```

**Add 设置**

```java
// 计算当前日期十天后的时间
Calendar c1 = Calendar.getInstance();
c1.add(Calendar.DATE, 10);
```

**get 获取对象信息**

```java
// 获取某一个参数，例如日
public void get(int field,int value)
```

#### 17.  正则表达式

##### java.util.regex 包

- Pattern 类：

  pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。

- Matcher 类：

  Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。

- PatternSyntaxException：

  PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。

##### 捕获组

- 捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。

##### start 和 end 方法

- 返回匹配字符串开始和结束的位置。

##### matches 和 lookingAt 方法

- matches 要求整个序列都匹配，而lookingAt 不要求。

- lookingAt 方法虽然不需要整句都匹配，但是需要从第一个字符开始匹配。

##### replaceFirst 和 replaceAll 方法

replaceFirst 和 replaceAll 方法用来替换匹配正则表达式的文本。不同的是，replaceFirst 替换首次匹配，replaceAll 替换所有匹配。

##### appendReplacement 和 appendTail 方法

Matcher 类也提供了appendReplacement 和 appendTail 方法用于文本替换。

#### 18.  方法

##### 方法的定义

```java
修饰符 返回值类型 方法名(参数类型 参数名){
    ...    
    方法体
    ...    
    return 返回值; 
}
```

##### 方法调用

- 当方法返回一个值的时候，方法调用通常被当做一个值。
- 当方法返回值是void，方法调用一定是一条语句。

##### void 关键字

一个void方法的调用一定是一个语句。

##### 通过值传递参数

调用一个方法时候需要提供参数，你必须按照参数列表指定的顺序提供。

##### 方法的重载

- 就是说一个类的两个方法拥有相同的名字，但是有不同的参数列表。

- 重载的方法必须拥有不同的参数列表。你不能仅仅依据修饰符或者返回类型的不同来重载方法。

##### 变量作用域

- 变量的范围是程序中该变量可以被引用的部分。

##### 命令行参数的使用

- 运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。

- 命令行参数是在执行程序时候紧跟在程序名字后面的信息。

##### 构造方法

- 当一个对象被创建时候，构造方法用来初始化该对象。
- 构造方法和它所在类的名字相同，但构造方法没有返回值。

##### 可变参数

```java
typeName... parameterName
```

- 在方法声明中，在指定参数类型后加一个省略号(...) 。

- 一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。

##### finalize() 方法

- 在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。

```java
protected void finalize()
{
   // 在这里终结代码
}
```

- 关键字 protected 是一个限定符，它确保 finalize() 方法不会被该类以外的代码调用。

#### 19.  流(Stream)、文件(File)和IO

##### 读取控制台输入

```java
BufferedReader br = new BufferedReader(new                       InputStreamReader(System.in));
```

##### 从控制台读取多字符输入

```java
int read( ) throws IOException
```

##### 从控制台读取字符串

```java
String readLine( ) throws IOException
```

##### 控制台输出

```java
void write(int byteval)
```

##### 读写文件

###### FileInputStream

- 该流用于从文件读取数据，它的对象可以用关键字 new 来创建。

- 有多种构造方法可用来创建对象。

可以使用字符串类型的文件名来创建一个输入流对象来读取文件。

```java
InputStream f = new FileInputStream("C:/java/hello");
```

也可以使用一个文件对象来创建一个输入流对象来读取文件。

```java
File f = new File("C:/java/hello"); 
InputStream in = new FileInputStream(f);
```

###### FileOutputStream

- 该类用来创建一个文件并向文件中写数据。

- 如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。

- 有两个构造方法可以用来创建 FileOutputStream 对象。

使用字符串类型的文件名来创建一个输出流对象。

```java
OutputStream f = new FileOutputStream("C:/java/hello")
```

也可以使用一个文件对象来创建一个输出流来写文件。

```java
File f = new File("C:/java/hello"); 
OutputStream fOut = new FileOutputStream(f);
```



