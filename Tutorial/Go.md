# Go 语言结构

## 1. GO 语言结构

### 1.1. 基础组成

- 包声明：`package main`，必须在源文件非注释的第一行添加，并且一个文件夹必须属于同一个包名。
- 引入包：`import "fmt"`，告诉 Go 语言编译器，此程序需要使用 fmt 包。
- 函数：`func main()` ，main 函数是每个应用程序必须的函数，一般在启动后第一个执行，如果有 `init()` 函数，那么先执行该函数。
- 变量。
- 语句 & 表达式。
- 注释：`/*...*/`，在程序执行时被忽略。

### 1.2. 执行程序

```shell
go run filename.go
# 或者使用 build 生成二进制文件
go build filename.go
```

**注意：**函数的定义结构 `{` 不能单独放在一行。

## 2. Go 语言基础语法

### 2.1. 行分隔符

​	一行代表一个语句结束，如果需要多个语句写在同一行，需要使用 `;` 分隔。

### 2.2. 注释

​	注释不会被编译，每一个包应该有相关注释。单行注释是最常见的注释形式，可以在任何地方使用以 `//` 开头的单行注释。多行注释也叫块注释，均已以 `/*` 开头，并以 `*/` 结尾。

### 2.3. 标识符

​	标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母（A ~ Z和a ~ z）数字（0 ~ 9）、下划线 `_` 组成的序列，但是第一个字符必须是字母或下划线而不能是数字。

### 2.4. 字符串连接

​	Go 语言的字符串连接可以通过 `+` 实现。

### 2.5. 格式化字符串

​	Go 语言中使用 `fmt.Sprintf` 或 `fmt.Printf` 格式化字符串并赋值给新字符串：

- **Sprintf ：** 根据格式化参数生成格式化的字符串并**返回该字符串**；
- **Printf ：** 根据格式化参数生成格式化的字符串并**写入标准输出**。

## 3. Go 语言数据类型

### 3.1. 数据类型

| 类型           | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| **布尔型**     | 布尔型的值只可以是常量 `true` 或者 `false`。                 |
| **数字类型**   | 整型 `int` 和浮点型 `float32`、`float64`，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 |
| **字符串类型** | Go 的字符串是由单个字节连接起来的，其字节使用 UTF-8 编码标识 Unicode 文本。 |
| **派生类型**   | 包含：指针、数组、结构体、Channel、函数、切片、接口、Map 等。 |

### 3.2. 数字类型

| 类型       | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| **uint8**  | 无符号 8 位整型（0 到 255）                                  |
| **uint16** | 无符号 16 位整型（0 到 65535）                               |
| **uint32** | 无符号 32 位整型（0 到 4294967295）                          |
| **uint64** | 无符号 64 位整型（0 到 18446744073709551615）                |
| **int8**   | 有符号 8 位整型（-128 到 127）                               |
| **int16**  | 有符号 16 位整型（-32768 到 32767）                          |
| **int32**  | 有符号 32 位整型（-2147483648 到 2147483647）                |
| **int64**  | 有符号 64 位整型（-9223372036854775808 到 9223372036854775807） |

### 3.3. 浮点型

| 类型           | 描述                  |
| :------------- | :-------------------- |
| **float32**    | IEEE-754 32位浮点型数 |
| **float64**    | IEEE-754 64位浮点型数 |
| **complex64**  | 32 位实数和虚数       |
| **complex128** | 64 位实数和虚数       |

### 3.4. 其他数字类型

| 类型        | 描述             |
| :---------- | :--------------- |
| **byte**    | 类似 uint8       |
| **rune**    | 类似 int32       |
| **uint**    | 32 或 64 位      |
| **int**     | 与 uint 一样大小 |
| **uintptr** | 用于存放一个指针 |

## 4. Go 语言变量

​	声明变量的一般形式是使用 `var` 关键字。

### 4.1. 变量声明

#### 4.1.1. 指定类型

​	用于声明非全局变量。

```go
var v_name v_type
v_name = value // 如果没有初始化，默认为 0 false "" nil 等
```

#### 4.1.2. 自行判断类型

```go
var v_name = value
```

#### 4.1.3. := 声明

​	只能在函数定义中出现。

```go
v_name := value
// 等价于 4.1. 中两句声明
```

#### 4.1.4. 多变量声明

```go
// 同时声明多个类型相同的变量 非全局变量
var v_name1, v_name2, v_name3 type
v_name1, v_name2, v_name3 = value1, value2, value3
// 自动判断多个变量类型
var v_name1, v_name2, v_name3 = value1, value2, value3
// 直接定义未声明的变量 
v_name1, v_name2, v_name3 := value1, value2, value3

// 因式分解关键字，用于声明全局变量
var (
	v_name1 type1
  v_name2 type2
)
```

### 4.2. 值类型 & 引用类型

#### 4.2.1. 值类型

​	所有像 `int`、`float`、`bool` 和 `string` 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。当使用等号 `=` 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 i 的值进行了拷贝。

#### 4.2.2. 引用类型

​	一个引用类型的变量存储的是其值所在的**内存地址**，或内存地址中第一个字所在的位置。这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。

## 5. Go 语言常量

### 5.1. 常量声明

​	常量是一个简单值的标识符，在程序运行时，不会被修改的量，其数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。

```go
const identifier [type] = value
```

- 显式类型定义： `const b string = "abc"`；
- 隐式类型定义： `const b = "abc"`。

#### 5.1.1. 多个常量声明

```go
const c_name1, c_name2 = value1, value2
```

### 5.2. 常量枚举

​	常量也可以用于枚举，枚举中可以用 `len()`，`cap()`，`unsafe.Sizeof()`函数计算表达式的值。

```go
const (
    Unknown = 0
    Female = 1
    Male = 2
)
```

**注意：**枚举中的函数必须是内置函数，否则编译不过。

#### 5.2.1. iota

​	`iota`是一种特殊常量，可以认为是一个可以被编译器修改的常量，其在 `const` 关键字出现时将被重置为 0，`const` 中每新增一行常量声明后，将使 `iota` 计数一次。

## 6. Go 语言运算符

### 6.1. 算术运算符

| 运算符 | 描述 |
| :----- | :--- |
| +      | 相加 |
| -      | 相减 |
| *      | 相乘 |
| /      | 相除 |
| %      | 求余 |
| ++     | 自增 |
| --     | 自减 |

### 6.2. 关系运算符

| 运算符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| ==     | 检查两个值是否相等，如果相等返回 True 否则返回 False。       |
| !=     | 检查两个值是否不相等，如果不相等返回 True 否则返回 False。   |
| >      | 检查左边值是否大于右边值，如果是返回 True 否则返回 False。   |
| <      | 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   |
| >=     | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 |
| <=     | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 |

### 6.3. 逻辑运算符

| 运算符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| &&     | 逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 |
| \|\|   | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。 |
| !      | 逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。 |

### 6.4. 位运算符

| 运算符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| &      | 对应的二进位相与                                             |
| \|     | 对应的二进位相或                                             |
| ^      | 对应的二进位相异或，当两对应的二进位相异时，结果为 1         |
| <<     | 左边的运算数的各二进位左移若干位，右边的数指定移动的位数，高位丢弃，低位补0 |
| >>     | 左边的运算数的各二进位全部右移若干位，右边的数指定移动的位数 |

### 6.5. 赋值运算符

| 运算符 | 描述                         |
| :----- | :--------------------------- |
| =      | 将一个表达式的值赋给一个左值 |
| +=     | 相加后再赋值                 |
| -=     | 相减后再赋值                 |
| *=     | 相乘后再赋值                 |
| /=     | 相除后再赋值                 |
| %=     | 求余后再赋值                 |
| <<=    | 左移后赋值                   |
| >>=    | 右移后赋值                   |
| &=     | 按位与后赋值                 |

### 6.6. 其他运算符

| 运算符 | 描述             |
| :----- | :--------------- |
| &      | 返回变量存储地址 |
| *      | 指针变量         |

## 7. Go 语言语句

### 7.1. 条件语句

| 语句           | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| if 语句        | 由一个布尔表达式后紧跟一个或多个语句组成                     |
| if...else 语句 | **else** 语句中的表达式在布尔表达式为 false 时执行           |
| if 嵌套语句    | 嵌入一个或多个 **if** 或 **else if** 语句                    |
| switch 语句    | **switch** 语句用于基于不同条件执行不同动作                  |
| select 语句    | **select** 语句类似于 **switch** 语句，但是select会随机执行一个可运行的case，如果没有case可运行，它将阻塞，直到有case可运行 |

**注意：**Go 没有三目运算符，所以不支持 `?:` 形式的条件判断。

### 7.2. 循环语句

#### 7.2.1. 循环类型

| 循环类型 | 描述                                 |
| :------- | :----------------------------------- |
| for 循环 | 重复执行语句块                       |
| 循环嵌套 | 在 for 循环中嵌套一个或多个 for 循环 |

#### 7.2.1. 循环控制语句

​	循环控制语句可以控制循环体内语句的执行过程。

| 控制语句      | 描述                                           |
| :------------ | :--------------------------------------------- |
| break 语句    | 用于中断当前 for 循环或跳出 switch 语句        |
| continue 语句 | 跳过当前循环的剩余语句，然后继续进行下一轮循环 |
| goto 语句     | 将控制转移到被标记的语句                       |

## 8. Go 语言函数

### 8.1. 函数定义

```go
func function_name( [parameter list] ) [return_types] {
   // function_body
}
```

- **func ：**函数由 `func` 开始声明；
- **function_name ：**函数名称，参数列表和返回值类型构成了函数签名；
- **parameter list ：**参数列表，指定的是参数类型、顺序、及参数个数；
- **return_types ：**返回类型，函数返回一列值，`return_types` 是该列值的数据类型；
- **funtion_body ：**函数定义的代码集合。

### 8.2. 函数参数

| 传递类型 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| 值传递   | 将实际参数复制一份传递到函数中，如果对参数进行修改，将不会影响到实际参数 |
| 引用传递 | 将实际参数的地址传递到函数中，对参数所进行的修改，将影响到实际参数 |

### 8.3. 函数用法

#### 8.3.1. 函数作实参

​	在 Go 语言中，不能在一个函数中定义另一个有名字函数，只能定义匿名函数，并且在定义的同时将其赋值一个函数名，调用方法与外部函数相同。

```go
funtion_name := func () {
  // funtion_body
}
```

#### 8.3.2. 函数闭包

​	Go 语言支持使用匿名函数作为闭包。匿名函数是一个"内联"语句或表达式，其优越性在于可以直接使用函数内的变量，不必申明。

#### 8.3.3. 函数方法

​	一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。只有给定类型才可以正确调用该方法。

```go
func (variable_name variable_data_type) function_name() [return_type]{
   /* 函数体 */
}
```

## 9. Go 语言变量作用域

### 9.1. 局部变量

​	在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。

### 9.2. 全局变量

​	在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。

### 9.3. 形式参数

​	形式参数会作为函数的局部变量来使用。

## 10. Go 语言数据结构

### 10.1. 数组

#### 10.1.1. 声明数组

```go
var arrayName [size]dataType
```

​	如果数组长度不确定，可以用 `...` 代替数组长度，Go 语言会根据元素的个数来设置数组的大小。

```go
var arrayName [...]dataType
```

#### 10.1.2. 初始化数组

```go
var numbers = [5]int{1, 2, 3, 4, 5}
// 或者
numbers := [5]int{1, 2, 3, 4, 5}
```

**注意：**在 Go 语言中，数组的大小是类型的一部分，因此不同大小的数组是不兼容的，也就是说 `[5]int` 和 `[10]int` 是不同的类型。

#### 10.1.3. 访问数组元素

​	数组元素可以通过索引（位置）来读取。

```go
var v_name = arrayName[n]
```

#### 10.1.4. 多维数组

```go
var variable_name [SIZE1][SIZE2]...[SIZEN] variable_type
```

#### 10.1.5. 向函数传递数组

​	形参设定数组大小。

```go
func myFunction(param [10]int) {
	// ....
}
```

​	形参未设定数组大小。

```go
func myFunction(param []int) {
	// ....
}
```

### 10.2. 指针

#### 10.2.1. 指针声明

```go
var var_name *var-type
```

#### 10.2.2. 空指针

​	当一个指针被定义后没有分配到任何变量时，它的值为 `nil`。

#### 10.2.3. 指针数组

​	有时候我们需要使用多个指针去保存多个值，这时候需要声明指针数组。

```go
var ptr_name [n]*value_type
```

#### 10.2.4. 指向指针的指针

​	如果指针变量存放的又是另一个指针变量的地址，则称这个指针变量为指向指针的指针变量。

```go
var ptr_name **value_type
```

#### 10.2.5. 作为函数参数

​	向函数传递指针，只需要在函数定义的参数上设置为指针类型即可。

### 10.3. 结构体

#### 10.3.1. 定义结构体

​	结构体定义需要使用 `type` 和 `struct` 语句。

```go
type struct_variable_type struct {
   member definition
   member definition
   ...
   member definition
}
```

​	定义了之后可以使用结构名声明新的变量。

```go
variable_name := structure_variable_type {value1, value2...valuen}
// 或
variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}
```

#### 10.3.2. 访问结构体成员

​	使用点号 `.` 操作符。

```go
struct_name.variable_name
```

#### 10.3.3. 结构体指针

​	可以定义指向结构体的指针类似于其他指针变量。

```go
var struct_pointer *struct_type
```

​	以上定义的指针变量可以存储结构体变量的地址，赋值时，必须传递对应结构体的地址。

```go
struct_pointer = &struc_object
```

​	使用结构体指针访问结构体成员，使用 `.` 操作符。

```go
struct_pointer.title
```

### 10.4. 切片

​	切片是对数组的抽象，数组的长度不可改变，与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。

#### 10.4.1. 定义切片

​	切片不需要说明长度。

```go
var identifier []type
```

​	或使用 `make()` 函数来创建切片，其中 `len` 为数组的长度并且也是切片的初始长度，`capacity` 为可选参数。

```go
var slice1 []type = make([]type, len)

也可以简写为

slice1 := make([]type, len, cap)
```

#### 10.4.2. 切片初始化

```go
// 直接初始化切片，[] 表示是切片类型，{1,2,3} 初始化值依次是 1,2,3，其 cap=len=3
s :=[] int {1,2,3 } 

// 初始化切片 s，是数组 arr 的引用
s := arr[:] 

// 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片
s := arr[startIndex:endIndex]

// 默认 endIndex 时将表示一直到arr的最后一个元素
s := arr[startIndex:]

// 默认 startIndex 时将表示从 arr 的第一个元素开始
s := arr[:endIndex]

// 通过切片 s 初始化切片 s1
s1 := s[startIndex:endIndex] 

// 通过内置函数 make() 初始化切片s，[]int 标识为其元素类型为 int 的切片
s := make([]int, len, cap) 
```

#### 10.4.3. len() & cap() 

​	切片是可索引的，并且可以由 `len()` 方法获取长度，并提供了计算容量的方法 `cap()` ，可以测量切片最长可以达到多少。

#### 10.4.4. 空切片

​	一个切片在未初始化之前默认为 nil，长度为 0。

#### 10.4.5. 切片截取

​	可以通过设置下限及上限来设置截取切片 `[lower-bound:upper-bound]`。

#### 10.4.6. append() & copy() 

​	如果想增加切片的容量，必须创建一个新的更大的切片并把原分片的内容都拷贝过来。

```go
// 追加在切片的后面
append(slice, value)
// 复制切片，将 slice2 的内容复制到 slice1
copy(slice1, slice2)
```

### 10.5. 集合

​	Map 是一种无序的键值对的集合，其**最重要**的一点是通过 `key` 来快速检索数据，`key` 类似于索引，指向数据的值。由于其无序性，遍历 Map 时返回的键值对的顺序是不确定的。

​	Map 是**引用类型**，如果将一个 Map 传递给一个函数或赋值给另一个变量，它们都指向同一个底层数据结构，因此对 Map 的修改会影响到所有引用它的变量。

#### 10.5.1. 定义 Map

​	可以使用内建函数 `make` 或使用 `map` 关键字来定义。

```go
/* 使用 make 函数 */
map_variable := make(map[KeyType]ValueType, initialCapacity)

/* 使用字面量创建 Map */
m := map[string]int{
    // body
}
```

##### 获取元素

```go
// 获取键值对
v1 := m["apple"]
// 如果键不存在，ok 的值为 false，v2 的值为该类型的零值
v2, ok := m["pear"]  
```

##### 修改元素

```go
// 修改键值对
m["apple"] = 5
```

##### 获取 Map 的长度

```go
// 获取 Map 的长度
len := len(m)
```

##### 遍历 Map

```go
// 遍历 Map
for k, v := range m {
    fmt.Printf("key=%s, value=%d\n", k, v)
}
```

##### 删除元素

```go
// 删除键值对
delete(m, "banana")
```

## 11. Go 语言范围（Range）

​	`range` 关键字用于 for 循环中迭代数组（array）、切片（slice）、通道（channel）或集合（map）的元素。在数组和切片中它返回 `index: value`，在集合中返回 `key: value` 。

```go
for key, value := range type_name {
  // loop body
}
```

​	以上代码中的 `key` 或 `value` 是可以省略。

```go
for key, _ := range ...
// 或
for _, value := range ...
```

## 12. Go 语言递归函数

​	Go 语言支持递归，但在使用递归时，需要设置退出条件，否则递归将陷入无限循环中。

## 13. Go 语言类型转换

```go
type_name(expression)
```

### 13.1. 数值类型转换

​	将整型转换为浮点型：

```go
var b float64 = float64(a)
```

### 13.2. 字符串类型转换

​	将一个字符串转换成另一个类型：

```go
var str string = "10"
var num int
// strconv.Atoi 返回整形和可能出现的错误
num, _ = strconv.Atoi(str)
```

### 13.3. 接口类型转换

​	接口类型转换有两种情况**：类型断言**和**类型转换**。

#### 13.3.1. 类型断言

​	类型断言用于将接口类型转换为指定类型。

```go
interface_variable.(type_name)
```

#### 13.3.2. 类型转换

​	类型转换用于将一个接口类型的值转换为另一个接口类型。

```
T(value)
```



































