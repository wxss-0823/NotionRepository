# Verilog

## 1. Verilog 基础教程

### 1.1. 基础语法

​	Verilog 是区分大小写的，格式自由，可以在一行内编写，也可以跨多行编写。每个语句必须以分号为结束符；空白符（`tab`、`space`、`enter`）都没有实际的意义，在编译阶段可以忽略。

#### 1.1.1. 注释

​	用 `//` 进行单行注释，用 `/* */` 进行多行注释。

#### 1.1.2. 标识符和关键字

​	标识符（identifier）可以是任意一组字母、数字、`$` 符号 和 `_` 符号的组合，但标识符的第一个字符必须是字母或者下划线，不能以数字或者美元开始。

​	关键字是 Verilog 中预留的用于定义语言结构的特殊标识符。Verilog 中关键字全部为小写。

### 1.2. 数值表示

#### 1.2.1. 数值种类

​	Verilog HDL 有下列四种基本的值来表示硬件电路中的电平逻辑。

- 0：逻辑 0 或 false；
- 1：逻辑 1 或 true；
- x：未知；
- z：高阻

​	`x` 意味着信号数值不确定，在实际电路里，信号可能为 1，也可能为 0；`z` 意味着信号处于高阻状态，常见于信号（input，reg）没有驱动时的逻辑结果，具体的逻辑值与实际电路中的上下拉有关，上拉为 1，下拉为 0。

#### 1.2.2. 整数数值表示

​	数字声明时，合法的技术格式有 4 种：十进制（`'d` 或 `'D`）、十六进制（`'h` 或 `'H`）、二进制（`'b` 或 `'B`）、八进制（`'o` 或 `'O`）。数据可指明位宽，也可不指明位宽。

##### 正数表示

```verilog
counter = 'd100 ;
counter = 100;
counter = 32'h64;
```

##### 负数表示

​	通常在位宽前加一个减号表示负数。

```verilog
counter = -6'd15
```

**注意**：减号放在基数和数字之间是非法的。

#### 1.2.3. 实数表示

##### 十进制

> 30.123
>
> 6.0
>
> 3.0
>
> 0.0001

##### 科学计数法

> 1.2e4
>
> 1_0001e4
>
> 1E-3

### 1.3. 数据类型

​	Verilog 最常用的 2 种数据类型就是线网 `wire` 与寄存器 `reg` ，其余类型可以理解为这两种数据类型的扩展辅助。

#### 1.3.1. 线网

​	`wire` 类型表示硬件单元之间的物理连线，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 `wire` 型变量，缺省值一般为 `Z`。

```verilog
wire interrupt;
wire flag1, flag2;
wire gnd = 1'b0;
```

​	线网型还有其他数据类型，包括 `wand`，`wor`，`wri`，`triand`，`trior`，`trireg` 等。这些数据类型使用的频率不是很高。

#### 1.3.2. 寄存器

​	`reg` 用来表示存储单元，他会保持数据原有的值，直到被改写。

```verilog
reg clk_temp;
reg flag1, flag2;
```

#### 1.3.3. 向量

​	当位宽大于 1 时， `wire` 或 `reg` 即可声明为向量的形式。

```verilog
reg		[3:0]				couter 		;
wire 	[32-1:0] 		gpio_data ;
wire 	[8:2] 			addr			;
reg 	[0:31]			data			;
```

​	对于向量，可以指定某一位或若干相邻位，作为其他逻辑使用。

```verilog
wire 			[9:0] data_low = data[0:9] 	;
addr_temp	[3:2] = addr[8:7] + 1'b1		;
```

​	Verilog 还支持指定 bit 位后固定位宽的向量域选择访问。

- `[bit+:width]`：从起始 bit 位开始递增，位宽为 width；
- `[bit-:width]`：从起始 bit 位开始递减，位宽为 width 。

​	对信号重新组合成新的向量时，需要借助大括号。

```verilog
wire [31:0] 		temp1, temp2;
assign temp1 = {byte1[0][7:0], data1[31:8]};
assign temp2 = {32{1'b0}};
```

#### 1.3.4. 整型

​	整型类型用关键字 `integer` 声明，声明时不用指定位宽，位宽和编译器有关，一般为 32 bit 。`reg` 型变量为无符号数，而 `integer` 型变量为有符号数。

```verilog
reg [31:0] 	data1				;
reg [7:0] 	byte [3:0]	;
integer 		j						;		// 整型变量，用来辅助生成数字电路
always@* begin
  for (j=0; j<=3; j=j+1) begin
    byte1[j] = data1[(j+1)*8-1 : j*8];
  end
end
```

**注意**：综合后实际电路里并没有 `j` 这个信号，`j` 只是辅助生成相应的硬件电路。

#### 1.3.5. 实数

​	实数用关键字 `real` 来声明，可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为 0 。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数。

```verilog
real 			data1		;
integer 	temp		;
initial begin
	data1 = 2e3;
  data1 = 3.75;
end

initial begin
  temp = data1		; 	// temp 值的大小为 3
end
```

#### 1.3.6. 时间

​	Verilog 使用特殊的时间寄存器 `time` 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 `$time` 获取当前仿真时间。

```verilog
time		current_time;
initial begin
	#100;
  current_time = $time ;	// current_time 的大小为 100
end
```

#### 1.3.7. 数组

​	在 Verilog 中允许声明 `reg` 、`wire` 、`integer` 、`time` 、`real` 及其向量类型的数组。数组维数没有限制。线网数组也可以用于连接实例模块的端口。数组中的每个元素都可以作为一个标量或者向量，以同样的方式来使用。

```verilog
integer				flag 			[7:0] 										;
reg 	[3:0]	 	counter 	[3:0]											; // 由 4 个 4 bit 计数器组成的数组
wire 	[7:0] 	addr_bus 	[3:0]											; // 由 4 个 8 bit wire 型变量组成的数组
wire  				data_bit 	[7:0][5:0]								;
reg 	[31:0] 	data_4d 	[11:0][3:0][3:0][255:0]		;
```

#### 1.3.8. 存储器

​	存储器变量就是一种寄存器数组，可用来描述 RAM 或 ROM 的行为。

```verilog
reg 				membit 	[0:255] 	;	// 256 bit 的 1 bit 存储器
reg		[7:0] mem 		[0:1023]	;	// 1 KB 存储器，位宽 1Byte = 8 bit
mem[511] = 8'b0								;	// 令第 511 个字节为 0
```

#### 1.3.9. 参数

​	参数用来表示常量，用关键字 `parameter` 声明，只能赋值一次。

```verilog
parameter	data_width = 10’d32 ;
parameter i=1, j=2,k=3 ;
parameter mem_size = data_width * 10 ;
```

​	通过实例化的方式，可以更改参数在模块中的值。

​	局部参数用 `localparam` 来声明，其作用和用法与 `parameter` 相同，区别在于它的值不能被改变。当参数只在本模块中调用时，可用 `localparam` 来声明。

#### 1.3.10. 字符串

​	字符串保存在 `reg` 类型的变量中，每个字符占用一个字节（8 bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。

​	字符串不能多行书写，即字符串中不能包含回车符。Verilog 将字符串当做一系列的单字节 ASCII 字符队列。

```verilog
reg [0: 14*8-1]    str;
initial begin
	str = "..."
end
```

##### 转义字符

| 转义字符 | 显示字符                 |
| -------- | ------------------------ |
| `\n`     | 换行                     |
| `\t`     | 制表符                   |
| `\`      | `\`                      |
| `%%`     | `%`                      |
| `\"`     | `"`                      |
| `\ooo`   | 1 到 3 个 8 进制数字字符 |

### 1.4. 表达式

​	表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。表达式可以在出现数值的任何地方使用。

#### 1.4.1. 操作数

​	操作数可以是任意的数据类型，只是某些特定的语法结构要求使用特定类型的操作数。操作数可以为常数、整数、实数、线网、寄存器、时间、位选、域选、存储器及函数调用等。

#### 1.4.2. 操作符

​	Verilog 中提供了大约 9 中操作符，分别是算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符。

​	大部分操作符与 C 语言中类似。同类型操作符之间，除条件操作符（三目运算符）从右往左关联，其余操作符都是自左向右关联。圆括号内的表达式优先执行。

#### 1.4.3. 优先级

| 操作符       | 操作符号                   |
| :----------- | :------------------------- |
| 单目运算     | `+` `-` `!` `~`            |
| 乘、除、取模 | `*` `/` `%`                |
| 加减         | `+` `-`                    |
| 移位         | `<<`  `>>`                 |
| 关系         | `<`   `<=` `>` `>=`        |
| 等价         | `==`   `!=` `===` `!===`   |
| 归约         | `&` `~&` `^` `~^` `|` `~|` |
| 按位         | `~` `&` `|` `^` `~^`       |
| 逻辑与       | `&&`                       |
| 逻辑或       | `||`                       |
| 条件         | `? :`                      |

#### 1.4.4. 算术操作符

​	算术操作符包括单目操作符和双目操作符。如果操作数的其中一位为 X，则计算结果也会全部为 X 。

​	对变量进行声明时，要根据变量的操作符对变量的位宽进行合理声明，不要让结果溢出。

​	`+` 、`-` 也可以作为单目操作符使用，表示操作数的正负性。此类操作符的优先级最高。

#### 1.4.5. 关系操作符

​	关系操作符结果有两种，真（1），假（0）。

#### 1.4.6. 等价操作符

​	等价操作符包括逻辑相等（`==`）、逻辑不等（`!=`）、全等（`===`）、非全等（`!==`）。其结果有两种，真，假。

​	等价操作符不能比较 X 或 Z，当操作数包含一个 X 或 Z，则结果为不确定值；全等操作符可以按位比较 X 或 Z，返回结果也可以为 1 。

#### 1.4.7. 逻辑操作符

​	逻辑操作符主要有 3 个：`&&` （逻辑与）、`||`（逻辑或）、`!`（逻辑非）。其计算结果为一个 1 bit 的值，0 表示假，1 表示真，X 表示不确定。

​	如果一个操作数不为 0，它等价于逻辑 1；如果一个操作数等于 0，它等价于逻辑 0；如果任意一位为 X 或 Z，它等价于 X 。

​	如果任意一个操作数包含 X，逻辑操作符运算结果不一定为 X 。

#### 1.4.8. 按位操作符

​	按位操作符包括：取反（`~`）、与（`&`）、或（`|`）、异或（`^`）、同或（`~^`）。

​	按位操作符对两个操作数的每 1 bit 数据进行按位操作，如果两个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。

#### 1.4.9. 归约操作符

​	归约操作符包括：归约与（`&`）、归约与非（`~&`）、归约或（`|`）、归约或非（`~|`），归约异或（`^`）、归约同或（`~^`）。

​	归约操作符只有一个操作数，它对这个操作数逐位进行操作，最终产生一个 1 bit 结果。

#### 1.4.10. 移位操作符

​	移位操作符包括：左移（`<<`）、右移（`>>`），算术左移（`<<<`）、算术右移（`>>>`）。

​	移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号与移动的位数。

​	算术左移和逻辑左移时，右边低位会补 0；逻辑右移时，左边高位会补 0，而算术右移时，左边高位会补符号位。

**注意**：算术左移会把最高位当做符号位处理，移位只在剩余位中进行。

#### 1.4.11. 拼接操作符

​	拼接操作符用大括号 `{, }` 表示，用于将多个操作数拼接成新的操作数，信号间用逗号隔开。

​	拼接符操作数必须指定位宽，常数也需要指定位宽。

#### 1.4.12. 条件操作符

​	条件表达式有 3 个操作符：

```verilog
condition_expression ? true_expression : false_expression
```

​	条件表达式类似于 2 路选择器，其描述方式完全可以用 `if-else` 语句代替，也可以进行嵌套，完成一次多次选择的逻辑。

#### 1.5. 编译指令

​	以反引号（`）开始的某些标识符是 Verilog 系统编译指令。

#### 1.5.1. \`define & \`undef

​	在编译阶段，\`define 用于文本替换，类似于 C 语言中的 `#define` 。一旦 \`define 指令被编译，其在整个编译过程中都会有效。

​	\`undef 用来取消之前的宏定义。

#### 1.5.2. \`ifdef \`ifndef \`elseif \`else \`endif

​	这些属于条件编译指令，用于根据定义情况，选择性地使用参数说明。

#### 1.5.3. \`include

​	使用 \`include 可以在编译时将一个 Verilog 文件内嵌到另一个 Verilog 文件中，作用类似于 C 语言中的 `#include` 结构。该指令通常用于将全局或公用的头文件包含在设计文件里。

​	文件路径既可以使用相对路径，也可以使用绝对路径。

#### 1.5.4. \`timescale

​	在 Verilog 模型中，时延有具体的单位时间表述，并用 \`timescale 编译指令将时间单位与实际时间相关联。

​	该指令用于定义时延、仿真的单位和精度。

```verilog
`timescale time_unit / time_precision
```

- `time_unit`：表示时间单位；
- `time_precision`：表示时间精度。

​	它们均是由数字以及单位组成。时间精度可以和时间单位一样，但是时间精度大小不能超过时间单位大小。

​	在编译过程中，\`timescale 指令会影响后面所有模块中的时延值，直至遇到另一个 \`timescale 指令或 \`resetall 指令。由于在 Verilog 中没有默认的 \`timescale，如果没有指定 \`timescale，Verilog 模块就会继承前面编译模块的 \`timescale 参数。

​	如果一个设计中的多个模块都带有 \`timescale，模拟器总是定位在所有模块中的最小时延精度上，并且所有时延都相应地换算为最小时延精度，时延单位并不受影响。

​	\`timescale 的时间精度设置是会影响仿真时间的，时间精度越小，仿真是占用内存越多，实际使用的仿真时间就越长。所以如果没有必要，应尽量将时间精度设置的大一点。

#### 1.5.5. \`default_nettype

​	该指令用于为隐式的线网变量指定类型，即将没有声明就使用的变量设置默认类型。

```verilog
`default_nettype wand	// 缺省为线与类型
`default_nettype none // 缺省不会自动产生 wire 变量
```

​	区别在于，指定默认类型，编译时只会产生警告，而不会产生错误；而不指定默认类型，如果未声明即使用，会产生错误，导致编译不通过。

#### 1.5.6. \`resetall

​	该编译器指令将所有的编译指令重新设置为缺省值。\`resetall 可以使得缺省连线类型为线网类型。将 \`resetall 添加到模块最后时，可以将当前的 \`timescale 取消放置进一步传递，只保证当前的 \`timescale 在局部有效，避免 \`timescale 的错误继承。

#### 1.5.7. \`celldefine & \`endcelldefine

​	这两个程序指令用于将模块标记为单元模块，包含模块的定义。

#### 1.5.8. \`unconnected_drive & \`nounconnected_drive

​	该指令用于，在模块实例化中，出现在这两个编译器指令间的任何未连接的输入端口，设置为正偏（上拉至高电平）电路状态或者反偏（下拉至低电平）电路状态。

```verilog
`unconnected_drive pull1
...
/* 在这两个程序指令间的所有未连接的输入端口为正偏电路状态 */
`nounconnected_drive

`unconnected_drive pull0
...
/* 在这两个程序指令间的所有未连接的输入端口为反偏电路状态 */
`nounconnected_drive
```

### 1.6. 连续赋值

#### 1.6.1. assign

​	连续赋值语句是 Verilog 数据流建模的基本语句，用于对 `wire` 型变量进行赋值。

​	Verilog 还提供了另一种对 `wire` 型赋值的简单方法，即在 `wire` 型变量声明的时候同时对其赋值。`wire` 型变量只能被赋值一次，因此该种连续赋值方式也只能有一次。

```verilog
assign LHS_target = RHS_expression ;
```

- `LHS`：Left Hand Side 指赋值操作的左侧；
- `RHS`：Right Hand Side 指赋值操作的右侧；

- `assign`：关键词，任何已经声明的 `wire` 型变量的连续赋值语句都是以 `assign` 开头。

**注意**：

1. `LHS_target` 必须是一个标量或者线性变量，而不能是寄存器类型；
2. `RHS_expression` 的类型没有要求，可以是标量或线型或寄存器向量，也可以是函数调用；
3. 只要 `RHS_expression` 表达式的操作数有事件发生时，`RHS_expression` 就会立刻重新计算，同时赋值给 `LHS_target` 。

### 1.7. 时延

#### 1.7.1. 时延

​	连续赋值延时语句中的延时，用于控制任意操作数发生变化到语句左端赋予新值之间的时间延时。时延一般是不可综合的。寄存器的时延也是可以控制的。

​	连续赋值时延一般可分为普通赋值时延、隐式时延、声明时延。

```verilog
// 普通时延，A&B 计算结果延时 10 个时间单位赋值给 Z
wire Z, A, B;
assign 
```

```verilog
// 隐式时延，声明一个 wire 型变量时对其进行包含一定时延的连续赋值
wire A, B;
wire #10 	Z = A & B;
```

```verilog
// 声明时延，声明一个 wire 型变量时指定一个时延，因此对该变量所有的连续赋值都会被推迟到指定的时间。除非门级建模中，一般不推荐使用此类方法建模
wire A, B;
wire #10 Z;
assign 		Z = A & B;
```

#### 1.7.2. 惯性时延

​	在上述例子中，A 或 B 任意一个变量发生变化，那么在 Z 得到新值之前，会有 10 个单位的时延。如果在 10 个时间单位内，即在 Z 获取新的值之前，A 或 B 任意一个值又发生了变化，那么计算 Z 的新值时会取 A 或 B 当前的新值。所以称之为惯性时延，即信号脉冲宽度小于时延时，对输出没有影响。

​	因此仿真时，时延一定要合理设置，放置某些信号不能进行有效的延迟。

### 1.8. 过程结构

#### 1.8.1. initial 语句

​	`initial` 语句从 0 时刻开始执行，只执行一次，多个 `initial` 块之间是相互独立的。如果 `initial` 块内包含多个语句，需要使用关键字 `begin` 和 `end` 组成一个块语句；如果 `initial` 块内只有一条语句，关键字 `begin` 和 `end` 可以省略。

​	`initial` 理论上来讲是不可综合的，多用于初始化、信号检测等。

#### 1.8.2. always 语句

​	与 `initial` 语句相反，`always` 语句是重复执行的。`always` 语句块从 0 时刻开始执行其中的行为语句；当执行完最后一条语句后，便再次执行语句块中的第一条语句，如此循环反复。

​	由于循环执行的特点，`always` 语句多用于仿真时钟的产生，信号行为的检测等。

### 1.9. 过程赋值

​	过程性赋值是在 `initial` 或 `always` 语句块里的赋值，赋值对象是寄存器、整数、实数等类型。这些变量在被赋值后，其值将保持不变，直到重新被赋予新值。

​	连续性赋值总是处于激活状态，任何操作数的改变都会影响表达式的结果，过程赋值只有在语句执行的时候，才会起作用。

#### 1.9.1. 阻塞赋值

​	阻塞赋值属于顺序执行，即在下一条语句执行前，当前语句一定会执行完毕。阻塞赋值语句使用 `=` 作为赋值符。

#### 1.9.2. 非阻塞赋值

​	非阻塞赋值属于并行执行语句，即下一条语句的执行和当前语句是同时进行的，它不会阻塞位于同一个语句块中后面语句的执行。非阻塞赋值使用 `<=` 作为赋值符。

**注意**：非阻塞赋值多用于shixu



















