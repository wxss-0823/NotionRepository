# Verilog

## 1. Verilog 基础教程

### 1.1. 基础语法

​	Verilog 是区分大小写的，格式自由，可以在一行内编写，也可以跨多行编写。每个语句必须以分号为结束符；空白符（`tab`、`space`、`enter`）都没有实际的意义，在编译阶段可以忽略。

#### 1.1.1. 注释

​	用 `//` 进行单行注释，用 `/* */` 进行多行注释。

#### 1.1.2. 标识符和关键字

​	标识符（identifier）可以是任意一组字母、数字、`$` 符号 和 `_` 符号的组合，但标识符的第一个字符必须是字母或者下划线，不能以数字或者美元开始。

​	关键字是 Verilog 中预留的用于定义语言结构的特殊标识符。Verilog 中关键字全部为小写。

### 1.2. 数值表示

#### 1.2.1. 数值种类

​	Verilog HDL 有下列四种基本的值来表示硬件电路中的电平逻辑。

- 0：逻辑 0 或 false；
- 1：逻辑 1 或 true；
- x：未知；
- z：高阻

​	`x` 意味着信号数值不确定，在实际电路里，信号可能为 1，也可能为 0；`z` 意味着信号处于高阻状态，常见于信号（input，reg）没有驱动时的逻辑结果，具体的逻辑值与实际电路中的上下拉有关，上拉为 1，下拉为 0。

#### 1.2.2. 整数数值表示

​	数字声明时，合法的技术格式有 4 种：十进制（`'d` 或 `'D`）、十六进制（`'h` 或 `'H`）、二进制（`'b` 或 `'B`）、八进制（`'o` 或 `'O`）。数据可指明位宽，也可不指明位宽。

##### 正数表示

```verilog
counter = 'd100 ;
counter = 100;
counter = 32'h64;
```

##### 负数表示

​	通常在位宽前加一个减号表示负数。

```verilog
counter = -6'd15
```

**注意**：减号放在基数和数字之间是非法的。

#### 1.2.3. 实数表示

##### 十进制

> 30.123
>
> 6.0
>
> 3.0
>
> 0.0001

##### 科学计数法

> 1.2e4
>
> 1_0001e4
>
> 1E-3

### 1.3. 数据类型

​	Verilog 最常用的 2 种数据类型就是线网 `wire` 与寄存器 `reg` ，其余类型可以理解为这两种数据类型的扩展辅助。

#### 1.3.1. 线网

​	`wire` 类型表示硬件单元之间的物理连线，由其连接的器件输出端连续驱动。如果没有驱动元件连接到 `wire` 型变量，缺省值一般为 `Z`。

```verilog
wire interrupt;
wire flag1, flag2;
wire gnd = 1'b0;
```

​	线网型还有其他数据类型，包括 `wand`，`wor`，`wri`，`triand`，`trior`，`trireg` 等。这些数据类型使用的频率不是很高。

#### 1.3.2. 寄存器

​	`reg` 用来表示存储单元，他会保持数据原有的值，直到被改写。

```verilog
reg clk_temp;
reg flag1, flag2;
```

#### 1.3.3. 向量

​	当位宽大于 1 时， `wire` 或 `reg` 即可声明为向量的形式。

```verilog
reg		[3:0]				couter 		;
wire 	[32-1:0] 		gpio_data ;
wire 	[8:2] 			addr			;
reg 	[0:31]			data			;
```

​	对于向量，可以指定某一位或若干相邻位，作为其他逻辑使用。

```verilog
wire 			[9:0] data_low = data[0:9] 	;
addr_temp	[3:2] = addr[8:7] + 1'b1		;
```

​	Verilog 还支持指定 bit 位后固定位宽的向量域选择访问。

- `[bit+:width]`：从起始 bit 位开始递增，位宽为 width；
- `[bit-:width]`：从起始 bit 位开始递减，位宽为 width 。

​	对信号重新组合成新的向量时，需要借助大括号。

```verilog
wire [31:0] 		temp1, temp2;
assign temp1 = {byte1[0][7:0], data1[31:8]};
assign temp2 = {32{1'b0}};
```

#### 1.3.4. 整型

​	整型类型用关键字 `integer` 声明，声明时不用指定位宽，位宽和编译器有关，一般为 32 bit 。`reg` 型变量为无符号数，而 `integer` 型变量为有符号数。

```verilog
reg [31:0] 	data1				;
reg [7:0] 	byte [3:0]	;
integer 		j						;		// 整型变量，用来辅助生成数字电路
always@* begin
  for (j=0; j<=3; j=j+1) begin
    byte1[j] = data1[(j+1)*8-1 : j*8];
  end
end
```

**注意**：综合后实际电路里并没有 `j` 这个信号，`j` 只是辅助生成相应的硬件电路。

#### 1.3.5. 实数

​	实数用关键字 `real` 来声明，可用十进制或科学计数法来表示。实数声明不能带有范围，默认值为 0 。如果将一个实数赋值给一个整数，则只有实数的整数部分会赋值给整数。

```verilog
real 			data1		;
integer 	temp		;
initial begin
	data1 = 2e3;
  data1 = 3.75;
end

initial begin
  temp = data1		; 	// temp 值的大小为 3
end
```

#### 1.3.6. 时间

​	Verilog 使用特殊的时间寄存器 `time` 型变量，对仿真时间进行保存。其宽度一般为 64 bit，通过调用系统函数 `$time` 获取当前仿真时间。

```verilog
time		current_time;
initial begin
	#100;
  current_time = $time ;	// current_time 的大小为 100
end
```

#### 1.3.7. 数组

​	在 Verilog 中允许声明 `reg` 、`wire` 、`integer` 、`time` 、`real` 及其向量类型的数组。数组维数没有限制。线网数组也可以用于连接实例模块的端口。数组中的每个元素都可以作为一个标量或者向量，以同样的方式来使用。

```verilog
integer				flag 			[7:0] 										;
reg 	[3:0]	 	counter 	[3:0]											; // 由 4 个 4 bit 计数器组成的数组
wire 	[7:0] 	addr_bus 	[3:0]											; // 由 4 个 8 bit wire 型变量组成的数组
wire  				data_bit 	[7:0][5:0]								;
reg 	[31:0] 	data_4d 	[11:0][3:0][3:0][255:0]		;
```

#### 1.3.8. 存储器

​	存储器变量就是一种寄存器数组，可用来描述 RAM 或 ROM 的行为。

```verilog
reg 				membit 	[0:255] 	;	// 256 bit 的 1 bit 存储器
reg		[7:0] mem 		[0:1023]	;	// 1 KB 存储器，位宽 1Byte = 8 bit
mem[511] = 8'b0								;	// 令第 511 个字节为 0
```

#### 1.3.9. 参数

​	参数用来表示常量，用关键字 `parameter` 声明，只能赋值一次。

```verilog
parameter	data_width = 10’d32 ;
parameter i=1, j=2,k=3 ;
parameter mem_size = data_width * 10 ;
```

​	通过实例化的方式，可以更改参数在模块中的值。

​	局部参数用 `localparam` 来声明，其作用和用法与 `parameter` 相同，区别在于它的值不能被改变。当参数只在本模块中调用时，可用 `localparam` 来声明。

#### 1.3.10. 字符串

​	字符串保存在 `reg` 类型的变量中，每个字符占用一个字节（8 bit）。因此寄存器变量的宽度应该足够大，以保证不会溢出。

​	字符串不能多行书写，即字符串中不能包含回车符。Verilog 将字符串当做一系列的单字节 ASCII 字符队列。

```verilog
reg [0: 14*8-1]    str;
initial begin
	str = "..."
end
```

##### 转义字符

| 转义字符 | 显示字符                 |
| -------- | ------------------------ |
| `\n`     | 换行                     |
| `\t`     | 制表符                   |
| `\`      | `\`                      |
| `%%`     | `%`                      |
| `\"`     | `"`                      |
| `\ooo`   | 1 到 3 个 8 进制数字字符 |

### 1.4. 表达式

​	表达式由操作符和操作数构成，其目的是根据操作符的意义得到一个计算结果。表达式可以在出现数值的任何地方使用。

#### 1.4.1. 操作数

​	操作数可以是任意的数据类型，只是某些特定的语法结构要求使用特定类型的操作数。操作数可以为常数、整数、实数、线网、寄存器、时间、位选、域选、存储器及函数调用等。

#### 1.4.2. 操作符

​	Verilog 中提供了大约 9 中操作符，分别是算术、关系、等价、逻辑、按位、归约、移位、拼接、条件操作符。

​	大部分操作符与 C 语言中类似。同类型操作符之间，除条件操作符（三目运算符）从右往左关联，其余操作符都是自左向右关联。圆括号内的表达式优先执行。

#### 1.4.3. 优先级

| 操作符       | 操作符号                   |
| :----------- | :------------------------- |
| 单目运算     | `+` `-` `!` `~`            |
| 乘、除、取模 | `*` `/` `%`                |
| 加减         | `+` `-`                    |
| 移位         | `<<`  `>>`                 |
| 关系         | `<`   `<=` `>` `>=`        |
| 等价         | `==`   `!=` `===` `!===`   |
| 归约         | `&` `~&` `^` `~^` `|` `~|` |
| 按位         | `~` `&` `|` `^` `~^`       |
| 逻辑与       | `&&`                       |
| 逻辑或       | `||`                       |
| 条件         | `? :`                      |

#### 1.4.4. 算术操作符

​	算术操作符包括单目操作符和双目操作符。如果操作数的其中一位为 X，则计算结果也会全部为 X 。

​	对变量进行声明时，要根据变量的操作符对变量的位宽进行合理声明，不要让结果溢出。

​	`+` 、`-` 也可以作为单目操作符使用，表示操作数的正负性。此类操作符的优先级最高。

#### 1.4.5. 关系操作符

​	关系操作符结果有两种，真（1），假（0）。

#### 1.4.6. 等价操作符

​	等价操作符包括逻辑相等（`==`）、逻辑不等（`!=`）、全等（`===`）、非全等（`!==`）。其结果有两种，真，假。

​	等价操作符不能比较 X 或 Z，当操作数包含一个 X 或 Z，则结果为不确定值；全等操作符可以按位比较 X 或 Z，返回结果也可以为 1 。

#### 1.4.7. 逻辑操作符

​	逻辑操作符主要有 3 个：`&&` （逻辑与）、`||`（逻辑或）、`!`（逻辑非）。其计算结果为一个 1 bit 的值，0 表示假，1 表示真，X 表示不确定。

​	如果一个操作数不为 0，它等价于逻辑 1；如果一个操作数等于 0，它等价于逻辑 0；如果任意一位为 X 或 Z，它等价于 X 。

​	如果任意一个操作数包含 X，逻辑操作符运算结果不一定为 X 。

#### 1.4.8. 按位操作符

​	按位操作符包括：取反（`~`）、与（`&`）、或（`|`）、异或（`^`）、同或（`~^`）。

​	按位操作符对两个操作数的每 1 bit 数据进行按位操作，如果两个操作数位宽不相等，则用 0 向左扩展补充较短的操作数。

#### 1.4.9. 归约操作符

​	归约操作符包括：归约与（`&`）、归约与非（`~&`）、归约或（`|`）、归约或非（`~|`），归约异或（`^`）、归约同或（`~^`）。

​	归约操作符只有一个操作数，它对这个操作数逐位进行操作，最终产生一个 1 bit 结果。

#### 1.4.10. 移位操作符

​	移位操作符包括：左移（`<<`）、右移（`>>`），算术左移（`<<<`）、算术右移（`>>>`）。

​	移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号与移动的位数。

​	算术左移和逻辑左移时，右边低位会补 0；逻辑右移时，左边高位会补 0，而算术右移时，左边高位会补符号位。

**注意**：算术左移会把最高位当做符号位处理，移位只在剩余位中进行。

#### 1.4.11. 拼接操作符

​	拼接操作符用大括号 `{, }` 表示，用于将多个操作数拼接成新的操作数，信号间用逗号隔开。

​	拼接符操作数必须指定位宽，常数也需要指定位宽。

#### 1.4.12. 条件操作符

​	条件表达式有 3 个操作符：

```verilog
condition_expression ? true_expression : false_expression
```

​	条件表达式类似于 2 路选择器，其描述方式完全可以用 `if-else` 语句代替，也可以进行嵌套，完成一次多次选择的逻辑。

#### 1.5. 编译指令

​	以反引号（`）开始的某些标识符是 Verilog 系统编译指令。

#### 1.5.1. \`define & \`undef

​	在编译阶段



































