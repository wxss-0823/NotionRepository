# Ruby 教程

## 1. Ruby 基础教程

### 1.1. 中文编码

​	首行添加一行注释，告诉解释器使用 UTF-8 来解析源码，并设置编辑器保存文件的编码为 UTF-8。

```ruby
# -*- coding: UTF-8 -*-
```

### 1.2. 命令行选项

​	Ruby 一般是从命令行运行，运行方式如下：

```shell
ruby [ options ] [.] [ programfile ] [ arguments ... ]
```

​	解释器可以通过下列选项被调用，来控制解释器的环境和行为。

| 选项          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| `-a`          | 与 `-n` 或 `-p` 一起使用，可以打开自动差分模式（auto split mode） |
| `—c`          | 只检查语法，不执行程序                                       |
| `-C dir`      | 在执行前改变目录（等价于 `-X`）                              |
| `-d`          | 启动调试模式（等价于 `-debug`）                              |
| `-F pat`      | 指定 pat 作为默认的分离模式（`$;`）                          |
| `-e prog`     | 指定 prog 作为程序在命令行中执行，可以指定多个 `-e`选项，用来指向多个程序 |
| `-h`          | 显示命令行选项的一个概览                                     |
| `-i [ ext]`   | 把文件内容重写为程序输出，原始文件会被加上扩展名 ext 保存下来；如果未指定 ext，原始文件会被删除 |
| `-I dir`      | 添加 dir 作为加载库的目录                                    |
| `-K [ kcode]` | 指定多字节字符集编码，e 或 E 对应 EUC （extended Unix code），s 或 S 对应 SJIS（Shift-JIS），u 或 U 对应 UTF-8，a、A、n 或 N 对应 ASCII |
| `-I`          | 启动自动行尾处理，从输入行取消一个换行符，并向输出行追加一个换行符 |
| `-n`          | 把代码放置在一个输入循环中（就像在 while get; ... end 中一样） |
| `-0 [ octal]` | 设置默认的记录分隔符（`$/`）为八进制，如果未指定 octal 默认为 \0 |
| `-p`          | 把代码放置在一个输入循环中，在每次迭代后输出变量 `$_` 的值   |
| `-r lib`      | 使用 `require` 来加载 lib 作为执行前的库                     |
| `-s`          | 解读程序名称和文件参数之间的匹配模式 -xxx 的任何参数作为开关，并定义相应的变量 |
| `-T [ level]` | 设置安全级别，执行不纯度测试（如果未指定 level ，则默认值为 1） |
| `-v`          | 显示版本，并启用冗余模式                                     |
| `-w`          | 启用冗余模式，如果未指定程序文件，则从 `STDIN` 读取          |
| `-x [ dir]`   | 删除 `#!ruby` 行之前的文本，如果指定了 dir，则把目录改变为 dir |
| `-X [ dir]`   | 在执行前改变目录（等价于 `-C`）                              |
| `-y`          | 启用解析器调试模式                                           |
| `--copyright` | 显示版权声明                                                 |
| `--debug`     | 启用调试模式（等价于 `-d`）                                  |
| `--help`      | 显示命令行选项的一个概览（等价于 `—h`）                      |
| `--verbose`   | 启用冗余模式（等价于 `-v`），设置 `$VERBOSE=true`            |
| `--yydebug`   | 启用解析器调试模式（等价于 `-y`）                            |

### 1.3. 环境变量

​	Ruby 解释器使用下列环境变量来控制它的行为。ENV 对象包含了所有当前设置的环境变量列表。

| 变量               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| `DLN_LIBRARY_PATH` | 动态加载模块搜索的路径                                       |
| `HOME`             | 当没有参数传递给 `Dir::chdir` 时，要移动到的目录             |
| `LOGDIR`           | 当没有参数传递给 `Dir::chdir`且未设置环境变量 `HOME` 时，要移动到的目录 |
| `PATH`             | 执行子进程的搜索路径，以及在指定 `-S` 选项后，Ruby 程序的搜索路径 |
| `RUBYLIB`          | 库的搜索路径                                                 |
| `RUBYLIB_PREFIX`   | 用于修改 `RUBYLIB` 搜索路径，通过格式 `path1;path2` 或 `path1path2`，把库的前缀 path1 替换为 path2 |
| `RUBYOPT`          | 传给 Ruby 解释器的命令行选项，在 taint 模式时被忽略（其中 `$SAFE>0`） |
| `RUBYPATH`         | 指定 `-S`选项后，Ruby 程序的搜索路径，优先级高于 PATH，在 taint 模式时被忽略（其中 `$SAFE>0`） |
| `RUBYSHELL`        | 指定执行命令时所使用的 shell，如果未设置该环境变量，则使用 shell 或 comspec |

### 1.4. 语法

​	所有的 Ruby 文件的扩展名都是 `.rb`，指定可用的 Ruby 解释器后，可以尝试运行程序。

#### 1.4.1. 程序中的空白

​	在 Ruby 代码中的空白字符，如空格和制表符一般会被忽略，除非当它们出现在字符串中时才不会被忽略，然而，有时候它们用于解释模棱两可的语句。当启用 `-w` 选项时，这种解释会产生警告。

```ruby
# 解释为两数相加
a + b
# 将 +b 解释为参数，a 解释为函数名
a +b
```

#### 1.4.2. 程序中的行尾

​	Ruby 把分号和换行符解释为语句的结尾。但是，如果 Ruby 在行尾遇到运算符，如：`+`、`-` 或 `\` 它们表示一个语句的延续。

#### 1.4.3. 标识符

​	标识符是变量、常量和方法的名称。Ruby 标识符是大小写敏感的，可以包含字母、数字和下划线字符。

#### 1.4.4. 保留字

​	Ruby 中的保留字不能作为常量或变量的名称，但是，它们可以作为方法名。

<table>
  <tr>
  	<td>BEGIN</td>
    <td>do</td>
    <td>next</td>
    <td>then</td>
  </tr>
  <tr>
  	<td>END</td>
    <td>else</td>
    <td>nil</td>
    <td>true</td>
  </tr>
  <tr>
  	<td>alias</td>
    <td>elsif</td>
    <td>not</td>
    <td>undef</td>
  </tr>
  <tr>
  	<td>and</td>
    <td>end</td>
    <td>or</td>
    <td>unless</td>
  </tr>
  <tr>
  	<td>begin</td>
    <td>ensure</td>
    <td>redo</td>
    <td>until</td>
  </tr>
  <tr>
  	<td>break</td>
    <td>false</td>
    <td>rescue</td>
    <td>when</td>
  </tr>
  <tr>
  	<td>case</td>
    <td>for</td>
    <td>retry</td>
    <td>while</td>
  </tr>
  <tr>
  	<td>class</td>
    <td>if</td>
    <td>return</td>
    <td>yield</td>
  </tr>
  <tr>
  	<td>def</td>
    <td>in</td>
    <td>self</td>
    <td>__FILE__</td>
  </tr>
  <tr>
  	<td>defined?</td>
    <td>module</td>
    <td>super</td>
    <td>__LINE__</td>
  </tr>
</table>

#### 1.4.5. Here Document

​	指建立多行字符串，在 `<<` 之后，可以指定一个字符串或标识符来终止字符串，且当前行之后指导终止符为止的所有行是字符串的值。

​	如果终止符用引号括起，引号的类型决定了操作字符串的类型。

**注意**：`<<` 和终止符之间必须没有空格。

#### 1.4.6. BEGIN 语句

​	声明的代码块在程序运行之前执行。

```ruby
BEGIN {
	code
}
```

#### 1.4.7. END 语句

​	声明的代码块在程序运行之后执行。

```ruby
END {
	code
}
```

#### 1.4.8. 注释

​	注释会对 Ruby 解释器隐藏一行，或者一行的一部分，或者若干行。可以在行首使用字符 `#`。

​	另一种注释的形式，通过块注释对解释器隐藏多行内容。

```ruby
=begin
...
...
...
=end
```

### 1.5. 数据类型

#### 1.5.1. 数值类型（Number）

##### 整型

​	整形分为两种，如果在 31 位以内（四字节），为 `Fixnum` 实例；如果超过，为 `Bignum`  实例。整数范围从 $-2^{30} \sim 2^{30}-1$，在这个范围内的整数是类 `Fixnum` 的对象，当整数值超过这个范围，会自动转化为 `Bignum` 类型。

​	可以在整数前使用一个可选的前导符号，0 对应八进制（Octal），0x 对应十六进制（Hex），0b 对应二进制（Binary），下划线字符在数字字符中被忽略。

##### 浮点数

​	Ruby 支持浮点数，它们是带有小数的数字。浮点数是类 `Float` 的对象，且可以是下列中任意一个。

```ruby
f1 = 0.0
f2 = 1.0e6
f3 = 4E20
f4 = 4e+20
```

##### 算术操作

​	加减乘除：`+ - * /`，指数操作符为： `**`，指数不必是整数。

#### 1.5.2. 字符串类型

​	Ruby 字符串简单地说是一个 8 位字节序列，它们是类 `String` 的对象。双引号标记的字符串允许替换和使用反斜线符号，可以使用 `#{expr}` 替换任意 Ruby 表达式的值为一个字符串； 单引号标记的字符串不允许替换，且只允许使用 `\\` 和 `\'` 两个反斜线符号。

#### 1.5.3. 数组

​	数组字面量通过 `[]` 中以逗号分隔定义，且支持 `range` 定义。

- 数组通过 `[]` 索引访问；
- 通过赋值操作插入、删除、替换元素；
- 通过 `+ -` 号进行合并和删除元素，且集合作为新集合出现；
- 通过 `<<` 号向原数组追加元素；
- 通过 `*` 号重复数组元素；
- 通过 `| &` 号做并集和交集操作。

#### 1.5.4. 哈希类型

​	Ruby 哈希是在大括号内放置一系列键值对，键和值之间使用逗号和序列 `=>` 分隔。尾部的逗号会被忽略。

#### 1.5.5. 范围类型

​	一个范围表示一个区间。范围类型通过设置一个开始值和结束值来表示。范围可使用 `s..e` 和 `s...e` 构造，或者通过 `Range.new` 来构造。

​	使用 `..` 构造的范围从开始值到结束值（包含结束值）；使用 `...` 构造的范围从开始值到结束值（不包含结束值）。当作为一个迭代器使用时，范围会返回序列中的每个值。

### 1.6. 类和对象

​	Ruby 是一种完美的面向对象编程语言。

#### 1.6.1. 定义类

```ruby
class ClassName
end
```

#### 1.6.2. 类中的变量

​	Ruby 提供了四种类型的变量：

- 局部变量：局部变量是在方法中定义的变量，在方法外不可用，局部变量以小写字母或 `_` 开始；
- 实例变量：实例变量可以跨任何特定的实例或对象中的方法使用，实例变量在变量之前放置符号 `@`；
- 类变量：类变量可以跨不同的对象使用，类变量属于类，且是类的一个属性，类变量在变量名之前放置符号 `@@`；
- 全局变量：类变量不能跨类使用，全局变量可以跨类使用，以美元符号 `$` 开始。

#### 1.6.3. 使用 new 方法创建对象

​	对象是类的实例，在 Ruby 中，可以使用类的方法 `new` 创建对象。方法 `new` 是一种独特的方法，在 Ruby 库中预定义，`new` 方法属于类方法。

#### 1.6.4. 自定义方法创建 Ruby 对象

​	可以给方法 `new` 传递参数，这些参数可用于初始化类变量。当需要声明带参数的 `new` 方法时，需要在创建类的同时声明方法 `initialize`，`initialize` 是一种特殊类型的方法，将在调用带参数的类的 `new` 方法时执行。

#### 1.6.5. 成员函数

​	在 Ruby 中，函数被称为方法。类中的每个方法是以关键字 def 开始，后跟方法名。方法名总是以小写字母开头。在 Ruby 中，可以使用关键字 `end` 来结束一个方法。

```ruby
def functionName
end
```

### 1.7. 变量

​	变量是持有可被任何程序使用的任何数据的存储位置。Ruby 支持五中类型的变量。

- 一般小写字母开头、下划线开头：变量（Variable）；
- `$` 开头：全局变量（Global Variable）；
- `@` 开头：实例变量（Instance Variable）；
- `@@` 开头：类变量（Class Variable），类变量被共享在整个继承链中；
- 大写字母开头：常数（Constant）；

#### 1.7.1. 全局变量

​	全局变量以 `$` 开头，未初始化的全局变量的值为 nil，在使用 `-w` 选项后，会产生警告。给全局变量赋值会改变全局状态，所以不建议使用全局变量。

#### 1.7.2. 实例变量

​	实例变量以 `@` 开头，未初始化的实例变量值为 nil，在使用 `-w` 选项后，会产生警告。

#### 1.7.3. 类变量

​	类变量以 `@@` 开头，且必须初始化后才能在方法定义中使用。 引用一个未初始化的类变量会产生错误。类变量在定义它的类或模块的子类或子模块中可共享使用。在使用 `-w` 选项后，会产生警告。

#### 1.7.4. 局部变量

​	局部变量以小写字母或下划线 `_` 开头。局部变量的作用域从 class、module、def 或 do 到相对应的结尾或者从左大括号到右大括号。

​	当调用一个未初始化的局部变量是，它被解释为一个不带参数的方法。对未初始化的局部变量赋值也可以当做变量声明。变量会一直存在，直到当前域结束为止。局部变量的生命周期在 Ruby 解析程序时确定。

#### 1.7.5. 常量

​	常量以大写字母开头。定义在类或模块内的常量可以从类或模块的内部访问，定义在类或模块外的常量可以被全局访问。

​	常量不能定义在方法内。引用一个未初始化的常量会产生错误。对已经初始化的常量赋值会产生警告。

#### 1.7.6. 伪变量

​	它们是特殊的变量，有着局部变量的外观，但行为却像常量，不能给这些常量赋任何值。

- `self`：当前方法的接收器对象；
- `true`：代表逻辑真；
- `false`：代表逻辑假；
- `nil`：代表 undefined 值；
- `__FILE__`：当前源文件的名字；
- `__LINE__`：当前行在源文件中的编号。

### 1.8. 运算符

### 1.9. 注释

​	注释是在运行时会被忽略的 Ruby 代码内的注释行，单行注释以 `#` 字符开始，直到该行结束。

#### 1.9.1. 多行注释

​	可以使用 `=begin` 和 `=end` 语法注释多行。

### 1.10. 判断

#### 1.10.1. if...else 语句

```ruby
if conditional [then]
	code...
[elsif conditional [then]
	code...]...
[else 
	code...]
end
```

​	if 表达式用于条件执行。值 false 和 nil 为假，其他值都为真。如果 `conditional` 为真，则执行 code，否则，执行 `else` 子句中指定的 code。通常可以省略关键字 `then`，如果需要在一行内写出完整的 if 表达式，则必须以 `then` 隔开条件和程序体。

```ruby
if a == 4 then a = 7 end
```

**注意**：Ruby 使用关键字 `elsif` 。

#### 1.10.2. if 修饰符

```ruby
code if condition
```

​	if 修饰词组表示，当 if 右边的条件成立时，才执行 if 左边的式子。

#### 1.10.3. unless 语句

```ruby
unless conditional [then]
	code
[else 
	code ]
end
```

​	unless 和 if 表达式作用相反，即 conditional 为假，执行 code，否则，执行 `else` 子句指定的 code。

#### 1.10.4. unless 修饰符

```ruby
code unless conditional
```

​	unless 修饰词组表示，当 unless 右边的条件不成立时，才执行 unless 左边的式子。

#### 1.10.5. case 语句

```ruby
case expression
[when expression [, expression ...]] [then]
	code ]...
[else 
	code ]
end
```

​	case 先对一个 expression 进行匹配判断，然后根据匹配结果进行分支选择。它使用 `===` 运算符比较 `when` 指定的 `expression`，若一致的话就执行 `when` 部分的内容。通常可以省略 `then`，若想在一行内写出完整的 when 表达式，则必须以 `then` 分隔条件式和程序体。

### 1.11. 循环

#### 1.11.1 while 语句

```ruby
while conditional [do|:]
  code
end
```

​	当条件为真时，执行 code。语法中 `do|:` 可以省略不写，但若需要在一行内写出 while 表达式，则必须以 `do|:` 分隔条件式和程序体。

#### 1.11.2. while 修饰符

```ruby
code while conditional
# 或者
begin code
end while conditional
```

​	当条件为真时，执行 code。如果 while 修饰符跟在一个没有 `rescue` 或 `ensure` 子句的 `begin` 语句后面，code 会在 conditional 判断之前执行一次。

#### 1.11.3. until 语句

```ruby
until conditional [do]
	code
end
```

​	当 conditional 为假时，执行 code。语法中 `do` 可以省略不写，但若要在一行内写出 until 表达式，则必须以 `do` 分隔条件式和程序体。

#### 1.11.4. until 修饰符

```ruby
code until conditional
# 或者
begin
  code
end until conditional
```

​	当 conditional 为假时，执行 code。如果 until 修饰符跟在一个没有 `rescue` 或 `ensure` 子句的 `begin` 语句后面，code 会在 conditional 判断之前执行一次。

#### 1.11.5. for 语句

```ruby
for varialbe [, variable ...] in expression [do]
  code
end
```

​	先计算表达式得到一个对象，然后针对对象中的每个元素分别执行一次 code。上述循环几乎完全等价于下式：

```ruby
(expression).each do |variable[, variable ...]| code end
```

#### 1.11.6. break 语句

​	终止最内部的循环。如果在块内调用，则会终止相关块的方法（方法返回 nil）。

#### 1.11.7. next 语句

​	跳到循环的下一次迭代，如果在块内调用，则终止块的执行（`yield` 表达式返回 nil）。

#### 1.11.8. redo 语句

​	重新开始最内部的循环的该次迭代，不检查循环条件。如果在块内调用，则重新开始 `yield` 或 `call`。































































































































































































































































































## 2. Ruby 高级教程

