# Ruby 教程

## 1. Ruby 基础教程

### 1.1. 中文编码

​	首行添加一行注释，告诉解释器使用 UTF-8 来解析源码，并设置编辑器保存文件的编码为 UTF-8。

```ruby
# -*- coding: UTF-8 -*-
```

### 1.2. 命令行选项

​	Ruby 一般是从命令行运行，运行方式如下：

```shell
ruby [ options ] [.] [ programfile ] [ arguments ... ]
```

​	解释器可以通过下列选项被调用，来控制解释器的环境和行为。

| 选项          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| `-a`          | 与 `-n` 或 `-p` 一起使用，可以打开自动差分模式（auto split mode） |
| `—c`          | 只检查语法，不执行程序                                       |
| `-C dir`      | 在执行前改变目录（等价于 `-X`）                              |
| `-d`          | 启动调试模式（等价于 `-debug`）                              |
| `-F pat`      | 指定 pat 作为默认的分离模式（`$;`）                          |
| `-e prog`     | 指定 prog 作为程序在命令行中执行，可以指定多个 `-e`选项，用来指向多个程序 |
| `-h`          | 显示命令行选项的一个概览                                     |
| `-i [ ext]`   | 把文件内容重写为程序输出，原始文件会被加上扩展名 ext 保存下来；如果未指定 ext，原始文件会被删除 |
| `-I dir`      | 添加 dir 作为加载库的目录                                    |
| `-K [ kcode]` | 指定多字节字符集编码，e 或 E 对应 EUC （extended Unix code），s 或 S 对应 SJIS（Shift-JIS），u 或 U 对应 UTF-8，a、A、n 或 N 对应 ASCII |
| `-I`          | 启动自动行尾处理，从输入行取消一个换行符，并向输出行追加一个换行符 |
| `-n`          | 把代码放置在一个输入循环中（就像在 while get; ... end 中一样） |
| `-0 [ octal]` | 设置默认的记录分隔符（`$/`）为八进制，如果未指定 octal 默认为 \0 |
| `-p`          | 把代码放置在一个输入循环中，在每次迭代后输出变量 `$_` 的值   |
| `-r lib`      | 使用 `require` 来加载 lib 作为执行前的库                     |
| `-s`          | 解读程序名称和文件参数之间的匹配模式 -xxx 的任何参数作为开关，并定义相应的变量 |
| `-T [ level]` | 设置安全级别，执行不纯度测试（如果未指定 level ，则默认值为 1） |
| `-v`          | 显示版本，并启用冗余模式                                     |
| `-w`          | 启用冗余模式，如果未指定程序文件，则从 `STDIN` 读取          |
| `-x [ dir]`   | 删除 `#!ruby` 行之前的文本，如果指定了 dir，则把目录改变为 dir |
| `-X [ dir]`   | 在执行前改变目录（等价于 `-C`）                              |
| `-y`          | 启用解析器调试模式                                           |
| `--copyright` | 显示版权声明                                                 |
| `--debug`     | 启用调试模式（等价于 `-d`）                                  |
| `--help`      | 显示命令行选项的一个概览（等价于 `—h`）                      |
| `--verbose`   | 启用冗余模式（等价于 `-v`），设置 `$VERBOSE=true`            |
| `--yydebug`   | 启用解析器调试模式（等价于 `-y`）                            |

### 1.3. 环境变量

​	Ruby 解释器使用下列环境变量来控制它的行为。ENV 对象包含了所有当前设置的环境变量列表。

| 变量               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| `DLN_LIBRARY_PATH` | 动态加载模块搜索的路径                                       |
| `HOME`             | 当没有参数传递给 `Dir::chdir` 时，要移动到的目录             |
| `LOGDIR`           | 当没有参数传递给 `Dir::chdir`且未设置环境变量 `HOME` 时，要移动到的目录 |
| `PATH`             | 执行子进程的搜索路径，以及在指定 `-S` 选项后，Ruby 程序的搜索路径 |
| `RUBYLIB`          | 库的搜索路径                                                 |
| `RUBYLIB_PREFIX`   | 用于修改 `RUBYLIB` 搜索路径，通过格式 `path1;path2` 或 `path1path2`，把库的前缀 path1 替换为 path2 |
| `RUBYOPT`          | 传给 Ruby 解释器的命令行选项，在 taint 模式时被忽略（其中 `$SAFE>0`） |
| `RUBYPATH`         | 指定 `-S`选项后，Ruby 程序的搜索路径，优先级高于 PATH，在 taint 模式时被忽略（其中 `$SAFE>0`） |
| `RUBYSHELL`        | 指定执行命令时所使用的 shell，如果未设置该环境变量，则使用 shell 或 comspec |

### 1.4. 语法

​	所有的 Ruby 文件的扩展名都是 `.rb`，指定可用的 Ruby 解释器后，可以尝试运行程序。

#### 1.4.1. 程序中的空白

​	在 Ruby 代码中的空白字符，如空格和制表符一般会被忽略，除非当它们出现在字符串中时才不会被忽略，然而，有时候它们用于解释模棱两可的语句。当启用 `-w` 选项时，这种解释会产生警告。

```ruby
# 解释为两数相加
a + b
# 将 +b 解释为参数，a 解释为函数名
a +b
```

#### 1.4.2. 程序中的行尾

​	Ruby 把分号和换行符解释为语句的结尾。但是，如果 Ruby 在行尾遇到运算符，如：`+`、`-` 或 `\` 它们表示一个语句的延续。

#### 1.4.3. 标识符

​	标识符是变量、常量和方法的名称。Ruby 标识符是大小写敏感的，可以包含字母、数字和下划线字符。

#### 1.4.4. 保留字

​	Ruby 中的保留字不能作为常量或变量的名称，但是，它们可以作为方法名。

<table>
  <tr>
  	<td>BEGIN</td>
    <td>do</td>
    <td>next</td>
    <td>then</td>
  </tr>
  <tr>
  	<td>END</td>
    <td>else</td>
    <td>nil</td>
    <td>true</td>
  </tr>
  <tr>
  	<td>alias</td>
    <td>elsif</td>
    <td>not</td>
    <td>undef</td>
  </tr>
  <tr>
  	<td>and</td>
    <td>end</td>
    <td>or</td>
    <td>unless</td>
  </tr>
  <tr>
  	<td>begin</td>
    <td>ensure</td>
    <td>redo</td>
    <td>until</td>
  </tr>
  <tr>
  	<td>break</td>
    <td>false</td>
    <td>rescue</td>
    <td>when</td>
  </tr>
  <tr>
  	<td>case</td>
    <td>for</td>
    <td>retry</td>
    <td>while</td>
  </tr>
  <tr>
  	<td>class</td>
    <td>if</td>
    <td>return</td>
    <td>yield</td>
  </tr>
  <tr>
  	<td>def</td>
    <td>in</td>
    <td>self</td>
    <td>__FILE__</td>
  </tr>
  <tr>
  	<td>defined?</td>
    <td>module</td>
    <td>super</td>
    <td>__LINE__</td>
  </tr>
</table>

#### 1.4.5. Here Document

​	指建立多行字符串，在 `<<` 之后，可以指定一个字符串或标识符来终止字符串，且当前行之后指导终止符为止的所有行是字符串的值。

​	如果终止符用引号括起，引号的类型决定了操作字符串的类型。

**注意**：`<<` 和终止符之间必须没有空格。

#### 1.4.6. BEGIN 语句

​	声明的代码块在程序运行之前执行。

```ruby
BEGIN {
	code
}
```

#### 1.4.7. END 语句

​	声明的代码块在程序运行之后执行。

```ruby
END {
	code
}
```

#### 1.4.8. 注释

​	注释会对 Ruby 解释器隐藏一行，或者一行的一部分，或者若干行。可以在行首使用字符 `#`。

​	另一种注释的形式，通过块注释对解释器隐藏多行内容。

```ruby
=begin
...
...
...
=end
```

### 1.5. 数据类型

#### 1.5.1. 数值类型（Number）

##### 整型

​	整形分为两种，如果在 31 位以内（四字节），为 `Fixnum` 实例；如果超过，为 `Bignum`  实例。整数范围从 $-2^{30} \sim 2^{30}-1$，在这个范围内的整数是类 `Fixnum` 的对象，当整数值超过这个范围，会自动转化为 `Bignum` 类型。

​	可以在整数前使用一个可选的前导符号，0 对应八进制（Octal），0x 对应十六进制（Hex），0b 对应二进制（Binary），下划线字符在数字字符中被忽略。

##### 浮点数

​	Ruby 支持浮点数，它们是带有小数的数字。浮点数是类 `Float` 的对象，且可以是下列中任意一个。

```ruby
f1 = 0.0
f2 = 1.0e6
f3 = 4E20
f4 = 4e+20
```

##### 算术操作

​	加减乘除：`+ - * /`，指数操作符为： `**`，指数不必是整数。

#### 1.5.2. 字符串类型

​	Ruby 字符串简单地说是一个 8 位字节序列，它们是类 `String` 的对象。双引号标记的字符串允许替换和使用反斜线符号，可以使用 `#{expr}` 替换任意 Ruby 表达式的值为一个字符串； 单引号标记的字符串不允许替换，且只允许使用 `\\` 和 `\'` 两个反斜线符号。

#### 1.5.3. 数组

​	数组字面量通过 `[]` 中以逗号分隔定义，且支持 `range` 定义。

- 数组通过 `[]` 索引访问；
- 通过赋值操作插入、删除、替换元素；
- 通过 `+ -` 号进行合并和删除元素，且集合作为新集合出现；
- 通过 `<<` 号向原数组追加元素；
- 通过 `*` 号重复数组元素；
- 通过 `| &` 号做并集和交集操作。

#### 1.5.4. 哈希类型

​	Ruby 哈希是在大括号内放置一系列键值对，键和值之间使用逗号和序列 `=>` 分隔。尾部的逗号会被忽略。

#### 1.5.5. 范围类型

​	一个范围表示一个区间。范围类型通过设置一个开始值和结束值来表示。范围可使用 `s..e` 和 `s...e` 构造，或者通过 `Range.new` 来构造。

​	使用 `..` 构造的范围从开始值到结束值（包含结束值）；使用 `...` 构造的范围从开始值到结束值（不包含结束值）。当作为一个迭代器使用时，范围会返回序列中的每个值。

### 1.6. 类和对象

​	Ruby 是一种完美的面向对象编程语言。

#### 1.6.1. 定义类

```ruby
class ClassName
end
```

#### 1.6.2. 类中的变量

​	Ruby 提供了四种类型的变量：

- 局部变量：局部变量是在方法中定义的变量，在方法外不可用，局部变量以小写字母或 `_` 开始；
- 实例变量：实例变量可以跨任何特定的实例或对象中的方法使用，实例变量在变量之前放置符号 `@`；
- 类变量：类变量可以跨不同的对象使用，类变量属于类，且是类的一个属性，类变量在变量名之前放置符号 `@@`；
- 全局变量：类变量不能跨类使用，全局变量可以跨类使用，以美元符号 `$` 开始。

#### 1.6.3. 使用 new 方法创建对象

​	对象是类的实例，在 Ruby 中，可以使用类的方法 `new` 创建对象。方法 `new` 是一种独特的方法，在 Ruby 库中预定义，`new` 方法属于类方法。

#### 1.6.4. 自定义方法创建 Ruby 对象

​	可以给方法 `new` 传递参数，这些参数可用于初始化类变量。当需要声明带参数的 `new` 方法时，需要在创建类的同时声明方法 `initialize`，`initialize` 是一种特殊类型的方法，将在调用带参数的类的 `new` 方法时执行。

#### 1.6.5. 成员函数

​	在 Ruby 中，函数被称为方法。类中的每个方法是以关键字 def 开始，后跟方法名。方法名总是以小写字母开头。在 Ruby 中，可以使用关键字 `end` 来结束一个方法。

```ruby
def functionName
end
```

### 1.7. 变量

​	变量是持有可被任何程序使用的任何数据的存储位置。Ruby 支持五中类型的变量。

- 一般小写字母开头、下划线开头：变量（Variable）；
- `$` 开头：全局变量（Global Variable）；
- `@` 开头：实例变量（Instance Variable）；
- `@@` 开头：类变量（Class Variable），类变量被共享在整个继承链中；
- 大写字母开头：常数（Constant）；

#### 1.7.1. 全局变量

​	全局变量以 `$` 开头，未初始化的全局变量的值为 nil，在使用 `-w` 选项后，会产生警告。给全局变量赋值会改变全局状态，所以不建议使用全局变量。

#### 1.7.2. 实例变量

​	实例变量以 `@` 开头，未初始化的实例变量值为 nil，在使用 `-w` 选项后，会产生警告。

#### 1.7.3. 类变量

​	类变量以 `@@` 开头，且必须初始化后才能在方法定义中使用。 引用一个未初始化的类变量会产生错误。类变量在定义它的类或模块的子类或子模块中可共享使用。在使用 `-w` 选项后，会产生警告。

#### 1.7.4. 局部变量

​	局部变量以小写字母或下划线 `_` 开头。局部变量的作用域从 class、module、def 或 do 到相对应的结尾或者从左大括号到右大括号。

​	当调用一个未初始化的局部变量是，它被解释为一个不带参数的方法。对未初始化的局部变量赋值也可以当做变量声明。变量会一直存在，直到当前域结束为止。局部变量的生命周期在 Ruby 解析程序时确定。

#### 1.7.5. 常量

​	常量以大写字母开头。定义在类或模块内的常量可以从类或模块的内部访问，定义在类或模块外的常量可以被全局访问。

​	常量不能定义在方法内。引用一个未初始化的常量会产生错误。对已经初始化的常量赋值会产生警告。

#### 1.7.6. 伪变量

​	它们是特殊的变量，有着局部变量的外观，但行为却像常量，不能给这些常量赋任何值。

- `self`：当前方法的接收器对象；
- `true`：代表逻辑真；
- `false`：代表逻辑假；
- `nil`：代表 undefined 值；
- `__FILE__`：当前源文件的名字；
- `__LINE__`：当前行在源文件中的编号。

### 1.8. 运算符

#### 1.8.1. 算术运算符

| 运算符 | 描述                                    |
| :----- | :-------------------------------------- |
| `+`    | 加法 - 把运算符两边的操作数相加         |
| `-`    | 减法 - 把左操作数减去右操作数           |
| `*`    | 乘法 - 把运算符两边的操作数相乘         |
| `/`    | 除法 - 把左操作数除以右操作数           |
| `%`    | 求模 - 把左操作数除以右操作数，返回余数 |
| `**`   | 指数 - 执行指数计算                     |

#### 1.8.2. 比较运算符

| 运算符   | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| `==`     | 检查两个操作数的值是否相等，如果相等则条件为真               |
| `!=`     | 检查两个操作数的值是否相等，如果不相等则条件为真             |
| `>`      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真       |
| `<`      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真       |
| `>=`     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真 |
| `<=`     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真 |
| `<=>`    | 联合比较运算符。如果第一个操作数等于第二个操作数则返回 0，如果第一个操作数大于第二个操作数则返回 1，如果第一个操作数小于第二个操作数则返回 -1 |
| `===`    | 用于测试范围内是否包含某个值                                 |
| `.eql?`  | 如果接收器和参数具有相同的类型和相等的值，则返回 true        |
| `equal?` | 如果接收器和参数具有相同的对象 id，则返回 true               |

#### 1.8.3. 赋值运算符

| 运算符 | 描述                                                       |
| :----- | :--------------------------------------------------------- |
| `=`    | 简单的赋值运算符，把右操作数的值赋给左操作数               |
| `+=`   | 加且赋值运算符，把右操作数加上左操作数的结果赋值给左操作数 |
| `-=`   | 减且赋值运算符，把左操作数减去右操作数的结果赋值给左操作数 |
| `*=`   | 乘且赋值运算符，把右操作数乘以左操作数的结果赋值给左操作数 |
| `/=`   | 除且赋值运算符，把左操作数除以右操作数的结果赋值给左操作数 |
| `%=`   | 求模且赋值运算符，求两个操作数的模赋值给左操作数           |
| `**=`  | 指数且赋值运算符，执行指数计算，并赋值给左操作数           |

#### 1.8.4. 并行赋值

​	Ruby 也支持变量的并行赋值，使得多个变量可以通过一行的 Ruby 代码进行初始化。

```ruby
a, b, c = 10, 20, 30
```

#### 1.8.5. 位运算符

| 运算符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| `&`    | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中 |
| `|`    | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中     |
| `^`    | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中 |
| `~`    | 二进制补码运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0 |
| `<<`   | 二进制左移运算符，左操作数的值向左移动右操作数指定的位数     |
| `>>`   | 二进制右移运算符，左操作数的值向右移动右操作数指定的位数     |

#### 1.8.6. 逻辑运算符

| 运算符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| `and`  | 称为逻辑与运算符，如果两个操作数都为真，则条件为真           |
| `or`   | 称为逻辑或运算符，如果两个操作数中有任意一个非零，则条件为真 |
| `&&`   | 称为逻辑与运算符，如果两个操作数都非零，则条件为真           |
| `||`   | 称为逻辑或运算符，如果两个操作数中有任意一个非零，则条件为真 |
| `!`    | 称为逻辑非运算符，用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假 |
| `not`  | 称为逻辑非运算符，用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假 |

#### 1.8.7. 范围运算符

| 运算符 | 描述                                           |
| :----- | :--------------------------------------------- |
| `..`   | 创建一个从开始点到结束点的范围（包含结束点）   |
| `...`  | 创建一个从开始点到结束点的范围（不包含结束点） |

#### 1.8.8. defined? 运算符

​	`defined?` 是一个特殊的运算符，以方法调用的形式来判断传递的表达式是否已定义。它返回表达式的描述字符串，如果表达式未定义则返回 nil。

```ruby
# 如果 var 已经初始化，则为 true
defined? var
# 如果方法已经定义，则为 true
defined? method_call
# 如果存在可被 super 用户调用的方法，则为 true
defined? super
# 如果已传递代码块，则为 true
defined? yield
```

#### 1.8.9. 点运算符 & 双冒号运算符

​	可以通过在方法名称前加上类或模块名称和 `.` 来调用类或模块的方法；可以使用类或模块的名称和两个冒号 `::` 来引用类或模块中的常量。

​	`::` 是一元运算符，允许在类或模块内定义常量、实例方法和类方法，可以从类或模块外的任何地方进行访问。

**注意**：

- 在 Ruby 中，类和方法也可以被当作常量，只需要在表达式的常量名前加上 `::` 前缀，即可返回适当的类或模块对象；
- 如果 `::` 前的表达式为类或模块名称，则返回该类或模块内对应的常量值；如果 `::` 前没有前缀表达式，则返回主  Object 类中对应的常量值。

### 1.9. 注释

​	注释是在运行时会被忽略的 Ruby 代码内的注释行，单行注释以 `#` 字符开始，直到该行结束。

#### 1.9.1. 多行注释

​	可以使用 `=begin` 和 `=end` 语法注释多行。

### 1.10. 判断

#### 1.10.1. if...else 语句

```ruby
if conditional [then]
	code...
[elsif conditional [then]
	code...]...
[else 
	code...]
end
```

​	if 表达式用于条件执行。值 false 和 nil 为假，其他值都为真。如果 `conditional` 为真，则执行 code，否则，执行 `else` 子句中指定的 code。通常可以省略关键字 `then`，如果需要在一行内写出完整的 if 表达式，则必须以 `then` 隔开条件和程序体。

```ruby
if a == 4 then a = 7 end
```

**注意**：Ruby 使用关键字 `elsif` 。

#### 1.10.2. if 修饰符

```ruby
code if condition
```

​	if 修饰词组表示，当 if 右边的条件成立时，才执行 if 左边的式子。

#### 1.10.3. unless 语句

```ruby
unless conditional [then]
	code
[else 
	code ]
end
```

​	unless 和 if 表达式作用相反，即 conditional 为假，执行 code，否则，执行 `else` 子句指定的 code。

#### 1.10.4. unless 修饰符

```ruby
code unless conditional
```

​	unless 修饰词组表示，当 unless 右边的条件不成立时，才执行 unless 左边的式子。

#### 1.10.5. case 语句

```ruby
case expression
[when expression [, expression ...]] [then]
	code ]...
[else 
	code ]
end
```

​	case 先对一个 expression 进行匹配判断，然后根据匹配结果进行分支选择。它使用 `===` 运算符比较 `when` 指定的 `expression`，若一致的话就执行 `when` 部分的内容。通常可以省略 `then`，若想在一行内写出完整的 when 表达式，则必须以 `then` 分隔条件式和程序体。

### 1.11. 循环

#### 1.11.1 while 语句

```ruby
while conditional [do|:]
  code
end
```

​	当条件为真时，执行 code。语法中 `do|:` 可以省略不写，但若需要在一行内写出 while 表达式，则必须以 `do|:` 分隔条件式和程序体。

#### 1.11.2. while 修饰符

```ruby
code while conditional
# 或者
begin code
end while conditional
```

​	当条件为真时，执行 code。如果 while 修饰符跟在一个没有 `rescue` 或 `ensure` 子句的 `begin` 语句后面，code 会在 conditional 判断之前执行一次。

#### 1.11.3. until 语句

```ruby
until conditional [do]
	code
end
```

​	当 conditional 为假时，执行 code。语法中 `do` 可以省略不写，但若要在一行内写出 until 表达式，则必须以 `do` 分隔条件式和程序体。

#### 1.11.4. until 修饰符

```ruby
code until conditional
# 或者
begin
  code
end until conditional
```

​	当 conditional 为假时，执行 code。如果 until 修饰符跟在一个没有 `rescue` 或 `ensure` 子句的 `begin` 语句后面，code 会在 conditional 判断之前执行一次。

#### 1.11.5. for 语句

```ruby
for varialbe [, variable ...] in expression [do]
  code
end
```

​	先计算表达式得到一个对象，然后针对对象中的每个元素分别执行一次 code。上述循环几乎完全等价于下式：

```ruby
(expression).each do |variable[, variable ...]| code end
```

#### 1.11.6. break 语句

​	终止最内部的循环。如果在块内调用，则会终止相关块的方法（方法返回 nil）。

#### 1.11.7. next 语句

​	跳到循环的下一次迭代，如果在块内调用，则终止块的执行（`yield` 表达式返回 nil）。

#### 1.11.8. redo 语句

​	重新开始最内部的循环的该次迭代，不检查循环条件。如果在块内调用，则重新开始 `yield` 或 `call`。

### 1.12. 方法

​	Ruby 方法与其他编程语言中的函数类似。Ruby 方法用于捆绑一个或多个重复的语句到一个单元中。

​	方法名应以小写字母开头，如果以大写字母作为方法名的开头，Ruby 可能会把它当作常量，从而导致不正确地解析调用。方法应在调用之前定义，否则 Ruby 会产生未定义的方法调用异常。

```ruby
def method_name [([arg [= default]] ... [, * arg [, &expr ]])]
  expr..
end
```

#### 1.12.1. 返回值

​	Ruby 中的每个方法默认会返回一个值，这个返回值是最后一个语句的值。

#### 1.12.2. return 语句

​	Ruby 中的 `return` 语句用于从 Ruby 方法中返回一个或多个值。

```ruby
return [expr[ , expr...]]
```

#### 1.12.3. 可变数量的参数

​	Ruby 允许声明参数数量可变的方法，通过 `*var_name` 声明。

#### 1.12.4. 类方法

​	当方法定义在类的外部，方法默认标记为 `private`；另一方面，如果方法定义在类中，则默认标记为 `public`。方法默认的可见性和 `private` 标记可通过模块（Module）的 `public` 或 `private` 改变。当需要访问类的方法时，首先需要实例化类，然后使用对象，可以访问类的任何成员。

​	Ruby 提供了一种不用实例化即可访问方法的方式。

```ruby
class ClassName
  def ClassName.methodName
    ...
  end
end

ClassName.methodName
```

#### 1.12.5. alias 语句

​	这个语句用于为方法或全局变量起别名，别名不能在方法主体内定义。即使方法被重写，方法的别名也保持方法的当前定义。为编号的全局变量（`$1`，`$2` …）起别名是被禁止的，重写内置的全局变量可能会导致严重的问题。

```ruby
alias newName oldName
```

#### 1.12.6. undef 语句

​	这个语句用于取消方法定义，`undef` 不能出现在方法主体内。通过使用 `undef` 和 `alias`，类的接口可以从父类独立修改。

```ruby
undef methodName
```

### 1.13. 块

​	Ruby 有一个块的概念。

- 块由大量的代码组成；
- 块需要一个名称；
- 块中的代码总是包含在大括号 `{}` 内；
- 块总是从与其具有相同名称的函数调用；
- 可以使用 `yield` 语句来调用块。

#### 1.13.1. yield 语句

​	如果使用一个块作为参数调用函数，那么在函数内可以使用 `yield` 执行这个块内的代码。

```ruby
def test
  yield
end

test {puts "..."}
```

​	块也可以带参数调用，被调用时 `yield` 语句后跟参数。

```ruby
test {|var1, var2| statement}
```

#### 1.13.2. 块和方法

​	块可以作为参数传递给函数，如果需要传入一个块，那么在方法的最后一个参数前带有 `&`，用来接收该块，该变量可以调用一些块独有的方法。

```ruby
def test(&block)
  block.call
end
```

#### 1.13.3. BEGIN 和 END 块

​	每个 Ruby 源文件可以声明当文件被加载时要运行的代码块（BEGIN 块），以及程序完成执行后要运行的代码块（END 块）。

```ruby
BEGIN {
  ...
}
END {
  ...
}
```

### 1.14. 模块

​	模块（Module）是一种把方法、类和常量组合在一起的方式。

- 模块提供了一个命名空间可避免名字冲突；
- 模块实现 `mixin` 装置。

​	模块定义了一个命名空间，相当于一个沙盒，在里边方法和常量不会与其他地方的方法常量冲突。模块与类类似，但有如下不同：

- 模块不能实例化；
- 模块没有子类；
- 模块只能被另一个模块定义。

```ruby
module Identifier
  statement1
  statement2
  ...
end
```

#### 1.14.1. require 语句

​	`require` 语句类似于 C 和 C++ 中的 `include` 语句以及 Java 中的 `import` 语句。如果一个第三方的程序想要使用任何已定义的模块，则可以简单的使用 Ruby `require` 语句来加载模块文件。

```ruby
require filename
```

​	这里，文件扩展名不是必需的。需要使用 `$LOAD_PATH$ << "."` 告诉解释器引入文件的路径，也可以使用 `require_relative` 来从一个相对目录引用文件。

**注意**：文件包含相同的函数名称，引用会导致代码模糊，但是模块避免了这种大麦模块。

#### 1.14.2. include 语句

​	可以使用 `include` 语句在类中嵌入模块，类的方法可以调用嵌入模块的方法。

```ruby
$LOAD_PATH << '.'
require "FileName"

class ClassName
include ModuleName
  def methodName
    ModuleName.moduleMathodName
  end
end
```

#### 1.14.3. Mixins

​	Ruby 不直接支持多重继承，但是 Ruby 的模块（Module）提供了一种名为 `mixin` 的装置，它几乎消除了多重继承的需要。

​	Ruby 没有真正实现多重继承机制，而是采用 `mixin` 技术作为替代品，将模块 `include` 到类定义中，模块的方法就 mix 进了类中。

### 1.15. 字符串

​	Ruby 中的 String 对象用于存储或操作一个或多个字节序列。Ruby 字符串分为单引号字符串和双引号字符串，区别在于双引号字符串能够支持更多的转义字符。

#### 1.15.1. 单引号字符串

​	最简单的字符串是单引号字符串，如果需要使用单引号字符，需要在单引号字符串内使用反斜杠 `\` ，这样 Ruby 解释器就不会认为这个单引号字符是字符串的终止符号

#### 1.15.2. 双引号字符串

​	在双引号字符串中，可以使用 `#{}` 来计算表达式的值，或者在字符串中嵌入变量。

#### 1.15.3. 字符串变量

​	Ruby 还支持一种采用 `%q` 和 `%Q` 来引导的字符串变量，`%q` 使用的是单引号引用规则，`%Q` 使用的是双引号引用规则。跟在后面的分界符可以是任意一个非字母数字的单字节字符，如：`[, {, (, <, !` 等。字符串会一直读取到发现相匹配的结束符为止。

```ruby
%q|...|
%Q{...}
```

#### 1.15.4. 转义字符

​	下面列出了可使用反斜杠转义的转义字符和非打印字符。

**注意**：在一个双引号括起的字符串内，转义字符会被解析；在一个单引号括起的字符串内，转义字符不会被解析，原样输出。

| 反斜杠符号 | 十六进制字符 | 描述                                             |
| :--------- | :----------- | :----------------------------------------------- |
| `\a`       | 0x07         | 报警符                                           |
| `\b`       | 0x08         | 退格键                                           |
| `\r`       | 0x0d         | 回车符                                           |
| `\s`       | 0x20         | 空格符                                           |
| `\t`       | 0x09         | 制表符                                           |
| `\v`       | 0x0b         | 垂直制表符                                       |
| `\e`       | 0x1b         | 转义符                                           |
| `\f`       | 0x0c         | 换页符                                           |
| `\n`       | 0x0a         | 换行符                                           |
| `\cx`      |              | Control-x                                        |
| `\C-x`     |              | Control-x                                        |
| `\M-\C-x`  |              | Meta-Control-x                                   |
| `\x`       |              | 字符 x                                           |
| `\nnn`     |              | 八进制表示法，其中 n 的范围为 0.7                |
| `\xnn`     |              | 十六进制表示法，其中 n 的范围为 0.9、 a.f 或 A.F |

#### 1.15.5. 字符编码

​	Ruby 的默认字符集是 ASCII，字符可用单个字节表示。如果需要使用 UTF-8 或其他现代的字符集，字符可能是用一个到四个字节表示。可以在程序的开头使用 `$KCODE` 改变字符集。

```ruby
$KCODE = 'u'
```

| 编码 | 描述                               |
| :--- | :--------------------------------- |
| `n`  | None （与 ASCII 相同）             |
| `a`  | ASCII （与 none 相同），这是默认的 |
| `u`  | UTF-8                              |
| `e`  | EUC                                |

### 1.16. 数组

​	Ruby 数组是任何对象的有序整数索引集合。数组中的每个元素都有一个索引相关，并可通过索引进行获取。数组的索引从 0 开始，一个负数的索引相对于数组的末尾计数。Ruby 数组可存储诸如：`String`、`Integer`、`Fixnum`、`Hash`、`Symbol` 等对象，甚至可以是其他 `Array` 对象。Ruby 数组不需要指定大小，当向数组添加元素时，Ruby 数组会自动增长。

#### 1.16.1. 创建数组

​	创建数组时可以执行数组大小，或者不指定，也可以为数组每个元素赋值。

```ruby
arrays = Array.new
arrays = Array.new(10)
arrays = Array.new(4, "4")
```

​	`Array.new` 方法也可以接收一个块作为参数，在初始化时，用数组的索引作为参数，调用块的代码，并将返回值存入数组的对应索引内。

```ruby
arrays = Array.new(10) {|n| n = n**2}
```

​	数组还有另一种形式初始化。

```ruby
arrays = Array.[](1, 2, 3)
arrays = Array.[1, 2, 3]
```

​	Ruby 的核心模块中有一个只接收单个参数的 Array 方法，区别于上述的 Array 类，这个方法仅使用范围初始化数组。

```ruby
arrays = Array(1..9)
```

### 1.17. 哈希

​	哈希是一种键值对集合，类似于一个数组，只不过它的索引不局限于使用数字。Hash 的索引几乎可以是任何对象，其元素没有特定的顺序。

#### 1.17.1. 创建哈希

​	与数组一样，有多种方法创建哈希，可以使用类方法 `new` 创建一个空的哈希。

```ruby
hashs = Hash.new
```

​	也可以创建带有默认值的哈希，当访问带有默认值的哈希中的任何键时，如果键或值不存在，将返回默认值。

```ruby
hashs = Hash.new("...")
hashs = Hash.new "..."
```

​	类似于数组，Ruby 的核心模块中有一个可以接收键值对的 Hash 方法，可以为 Hash 指定每一个键值对。

```ruby
hashs = Hash["a" => 100, "b" => 200]
```

​	可以使用任何的 Ruby 对象作为键或值，甚至可以使用数组。

### 1.18. 日期 & 时间

​	`Time` 类在 Ruby 中用于表示日期和时间。它是基于操作系统提供的系统日期和时间之上。该类无法表示 1970 年之前或者 2038 年之后的日期。

#### 1.18.1. 创建当前日期和时间

```ruby
time = Time.new
puts time.inspect
```

#### 1.18.2. 获取 Date & Time 组件

​	可以使用 Time 对象来获取各种日期和时间的组件。

```ruby
puts time.year    # => 日期的年份
puts time.month   # => 日期的月份（1 到 12）
puts time.day     # => 一个月中的第几天（1 到 31）
puts time.wday    # => 一周中的星期几（0 是星期日）
puts time.yday    # => 365：一年中的第几天
puts time.hour    # => 23：24 小时制
puts time.min     # => 59
puts time.sec     # => 59
puts time.usec    # => 999999：微秒
puts time.zone    # => "UTC"：时区名称
```

#### 1.18.3. Time.utc Time.gm & Time.local

​	这些函数可用于格式化标准格式的日期。这些函数的所有组件如下：

```ruby
[sec,min,hour,day,month,year,wday,yday,isdst,zone]
```

​	这些数组传到不同的函数可以获取日期的不同格式。

```ruby
# July 8, 2008
Time.local(2008, 7, 8)  
# July 8, 2008, 09:10am，本地时间
Time.local(2008, 7, 8, 9, 10)   
# July 8, 2008, 09:10 UTC
Time.utc(2008, 7, 8, 9, 10)  
# July 8, 2008, 09:10:11 GMT （与 UTC 相同）
Time.gm(2008, 7, 8, 9, 10, 11)
```

​	类似于其他语言，Ruby 也可以获得从纪元以来的秒数。

```ruby
# 返回从纪元以来的秒数
time = Time.now.to_i  
 
# 把秒数转换为 Time 对象
Time.at(time)
 
# 返回从纪元以来的秒数，包含微秒
time = Time.now.to_f
```

#### 1.18.4. 时区和夏令时

​	可以使用 Time 对象来获取与时区和夏令时有关的所有信息。

```ruby
time.zone       # => "UTC"：返回时区
time.utc_offset # => 0：UTC 是相对于 UTC 的 0 秒偏移
time.zone       # => "PST"（或其他时区）
time.isdst      # => false：如果 UTC 没有 DST（夏令时）
time.utc?       # => true：如果在 UTC 时区
time.localtime  # 转换为本地时区
time.gmtime     # 转换回 UTC
time.getlocal   # 返回本地区中的一个新的 Time 对象
time.getutc     # 返回 UTC 中的一个新的 Time 对象
```

#### 1.18.5. 格式化时间和日期

​	有许多方式格式化日期和时间。

```ruby
# 2015-09-17 15:26:42 +0800
time.to_s
# Thu Sep 17 15:26:42 2015
time.ctime
# 2015-09-17 15:26:42 +0800
time.localtime
# 2015-09-17 15:26:42
time.strftime("%Y-%m-%d %H:%M:%S")
```

#### 1.18.6. 时间格式化指令

​	下面所列的指令用于和 `Time.strftime` 一起使用。

| 指令 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| `%a` | 星期几名称的缩写（比如 Sun）                                 |
| `%A` | 星期几名称的全称（比如 Sunday）                              |
| `%b` | 月份名称的缩写（比如 Jan）                                   |
| `%B` | 月份名称的全称（比如 January）                               |
| `%c` | 优选的本地日期和时间表示法                                   |
| `%d` | 一个月中的第几天（01 到 31）                                 |
| `%H` | 一天中的第几小时，24 小时制（00 到 23）                      |
| `%I` | 一天中的第几小时，12 小时制（01 到 12）                      |
| `%j` | 一年中的第几天（001 到 366）                                 |
| `%m` | 一年中的第几月（01 到 12）                                   |
| `%M` | 小时中的第几分钟（00 到 59）                                 |
| `%p` | 子午线指示（AM 或 PM）                                       |
| `%S` | 分钟中的第几秒（00 或 60）                                   |
| `%U` | 当前年中的周数，从第一个星期日（作为第一周的第一天）开始（00 到 53） |
| `%W` | 当前年中的周数，从第一个星期一（作为第一周的第一天）开始（00 到 53） |
| `%w` | 一星期中的第几天（Sunday 是 0，0 到 6）                      |
| `%x` | 只有日期没有时间的优先表示法                                 |
| `%X` | 只有时间没有日期的优先表示法                                 |
| `%y` | 不带世纪的年份表示（00 到 99）                               |
| `%Y` | 带有世纪的年份                                               |
| `%Z` | 时区名称                                                     |
| `%%` | % 字符                                                       |

#### 1.18.7. 时间算法

​	可以用时间做一些简单的算术。

```ruby
now = Time.now
past = now - 10
future = now + 10
```

### 1.19. 范围

​	Ruby 支持范围，并允许以不同的方式使用范围。

#### 1.19.1. 作为序列的范围

​	范围的第一个也是最常见的用途是表达序列。序列有一个起点、一个终点和一个在序列产生连续值的方式。Ruby 使用 `..` 和 `...` 范围运算符创建这些序列。两点形式创建一个包含指定最高值的范围，三点形式创建一个不包含指定的最高值的范围。

​	序列是一个 Range 对象，包含了两个 Fixnum 对象的引用。如果需要，可以使用 `to_a` 方法把范围转换为列表。

#### 1.19.2. 作为条件的范围

​	范围也可以作为条件表达式。

```ruby
case score
  when 0..40
  	"..."
  else
  	"..."
end
```

#### 1.19.3. 作为间隔的范围

​	范围的最后一个用途是间隔检测。用于检查指定值是否在指定的范围内，需要使用 `===` 相等运算符来完成计算。

```ruby
if ((1..10) === 5)
  puts "5 in (1..10)"
end
```

### 1.20. 迭代器

​	迭代器是集合支持的方法，存储一组数据成员的对象称为集合。在 Ruby 中，数组（Array）和哈希（Hash）可以称之为集合。迭代器返回集合的所有元素，一个接着一个。

#### 1.20.1. each 迭代器

​	`each` 迭代器返回数组或哈希的所有元素。`each` 迭代器总是与一个块关联，它向块返回数组的每个值，一个接着一个，值被存储在变量中。

```ruby
collection.each do |variable|
  ...
end
```

#### 1.20.2. collect 迭代器

​	`collect` 迭代器返回集合的所有元素。`collect` 方法不需要总是与一个块关联，`collect` 方法返回整个集合，不管它是数组或者是哈希。

```ruby
collection = collection.collect
```

**注意**：`collect` 方法不是数组间进行复制的正确方式，另一个称为 `clone` 的方法，用于复制一个数组到另一个数组。

### 1.21. 文件的输入与输出

​	Ruby 提供了一整套 I/O 相关的方法，在内核（Kernel）模块中实现。所有的 I/O 方法派生自 IO 类。

#### 1.21.1. puts 语句

​	`puts` 语句指示程序显示存储在变量中的值，这将在每行末尾添加一个新行。

```ruby
puts var
```

#### 1.21.2. gets 语句

​	`gets` 语句用于获取来自名为 `STDIN` 的标准屏幕的用户输入。

#### 1.21.3. putc 语句

​	`putc` 用于依次输出一个字符串，执行一次输入一个字符。

#### 1.21.4. print 语句

​	`print` 语句与 `puts` 语句类似，不同之处在于，`puts` 语句会在输出内容结束后跳到下一行，而使用 `print` 语句时，光标定位在同一行。

#### 1.21.5. 打开和关闭文件

##### File.new 方法

​	可以使用 `File.new` 方法创建一个 File 对象用于读取、写入或者读写，读写权限取决于 mode 参数，使用完成后，可以使用 `File.close` 方法来关闭该文件。

```ruby
aFile = File.new("filename", "mode")
# ...
aFile.close
```

##### File.open 方法

​	可以使用 `File.open` 方法创建一个新的 File 对象，并把该 File 对象赋值给文件，但是，`File.open` 和 `File.new` 方法不同之处在于，`File.open` 方法可以与块关联，而 `File.new` 方法不能。

```ruby
File.open("filename", "mode") do |aFile|
  ...
end
```

##### mode 列表

| 模式 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| r    | 只读模式，文件指针被放置在文件的开头，这是默认模式           |
| r+   | 读写模式，文件指针被放置在文件的开头                         |
| w    | 只写模式，如果文件存在，则重写文件；如果文件不存在，则创建一个新文件用于写入 |
| w+   | 读写模式，如果文件存在，则重写已存在的文件；如果文件不存在，则创建一个新文件用于读写 |
| a    | 只写模式，如果文件存在，则文件指针被放置在文件的末尾；如果文件不存在，则创建一个新文件用于写入 |
| a+   | 读写模式，如果文件存在，则文件指针被放置在文件的末尾；如果文件不存在，则创建一个新文件用于读写 |

#### 1.21.6. 读取和写入文件

​	用于简单 I/O 的方法也可用于所有 File 对象。`gets` 从标准输入读取一行，`aFile.gets` 从文件对象 `aFile` 读取一行。

##### sysread 方法

​	可以使用方法 `sysread` 来读取文件的内容，当使用方法 `sysread` 时，可以使用任意一种模式打开文件。该方法将读取指定文件的 `num` 个字符，文件指针被放置在文件中第 `num+1` 个字符的位置。

```ruby
aFile.sysread(num)
```

##### syswrite 方法

​	可以使用方法 `syswrite` 来向文件写入内容，当使用方法 `syswrite` 时，需要以写入模式打开文件。

```ruby
aFile.syswrite("...")
```

##### each_byte 方法

​	该方法属于类 File，方法 `each_byte` 可以迭代字符串中每个字符。

##### IO.readlines 方法

​	类 File 是类 IO 的一个子类，类 IO 也有一些用于操作文件的方法。`IO.readlines` 是 IO 类中的一个方法，该方法逐行返回文件的内容。返回值存储在一个数组内，一个值表示文件中一行的内容。

##### IO.foreach 方法

​	该方法也逐行返回输出，方法 `foreach` 与方法 `readlines` 之间不同的是，方法 `foreach` 与块相关联，但是不像 `readlines` 方法，`foreach` 不是返回一个数组。

```ruby
IO.foreach("input.txt") {|line| puts line}
```

####  1.21.7. 重命名和删除文件

​	可以通过 `rename` 和 `delete` 方法重命名和删除文件。

```ruby
# 重命名文件 test1.txt 为 test2.txt
File.rename("test1.txt", "test2,txt")
# 删除文件 test2.txt
File.delete("test2.txt")
```

#### 1.21.8. 文件模式和所有权

​	使用带有掩码的 `chmod` 方法来改变文件的模式或权限/访问列表。

```ruby
file.chmod(0777)
```

​	掩码的后三位与 Linux 中 `chmod` 的参数配置相同。

| 掩码 | 描述                               |
| :--- | :--------------------------------- |
| 4000 | 执行时设置用户 ID                  |
| 2000 | 执行时设置所属组 ID                |
| 1000 | 保存交换文本，甚至在使用后也会保存 |

#### 1.21.9. 文件查询

​	在打开文件前，可能需要对文件进行一些判断操作。

```ruby
# 判断文件是否存在
File.open("filename") if File::exists?("filename")
# 判断是否为文件
File.file?("filename")
# 判断给定的文件名是否是一个目录
File::directory?("directory")
# 判断文件是否可读、可写、可执行
File.readable?("filename")
File.writable?("filename")
File.excutable?("filename")
# 检查文件大小是否为 0
File.zero?("filename")
# 返回文件的大小
File.size?("filename")
# 检查文件的类型
File::ftype("filename")
# 检查文件被创建、修改或最后访问的时间
File::ctime("filename")
File::mtime("filename")
File::atime("filename")
```

#### 1.21.10. 目录

​	所有的文件都是包含在目录中，Ruby 提供了处理文件和目录的方式。File 类用于处理文件，Dir 类用于处理目录。

##### 浏览目录

​	为了在 Ruby 程序中改变目录，可以使用 `Dir.chdir` 。

```ruby
Dir.chdir("...")
# 返回当前目录
Dir.pwd
# 获取指定目录内文件和目录列表
Dir.entries("...").join(" ")
Dir.foreach("...").join("\n")
```

​	获取目录列表的更简洁的方式是通过使用 Dir 类数组的方法。

```ruby
Dir["..."]
```

##### 创建目录

​	`Dir.mkdir` 可用于创建目录。

```ruby
Dir.mkdir("directory", mask)
```

**注意**：掩码为三位整数，规则与 Linux 中权限掩码相同。

##### 删除目录

​	`Dir.delete` 可用于删除目录，`Dir.unlink` 和 `Dir.mkdir` 执行相同的功能。

```ruby
Dir.delete("directory")
```

#### 1.21.11. 创建文件 & 临时目录

​	临时文件是那些在程序执行过程中被简单地创建，但不会永久性存储地信息。`Dir.tmpdir` 提供了在当前系统上临时目录的路径，但是该方法默认情况下是不可用的，需要引入 `tmpdir` 模块。

​	可以把 `Dir.tmpdir` 和 `File.join` 一起使用，创建一个独立于平台的临时文件。Ruby 的标准库中也包含了一个名为 `Tempfile` 的库，该库可用于创建临时文件。

### 1.22. 异常

​	Ruby 提供了一个完美的处理异常的机制，可以在 `begin/end` 块中附上可能抛出异常的代码，并使用 `rescue` 子句告诉 Ruby 要处理的异常类型。

```ruby
# 开始
begin
  # 抛出异常
  raise
# 捕获异常的类型
rescue [ExceptionType = Standard Exception]
  $! # 表示异常信息
  $@ # 表示异常出现的代码位置
  ...
# 其他异常
else
  ...
# 不管有没有异常，都会执行该块
ensure
# 结束
end
```

​	从 `begin` 到 `rescue` 中的一切是受保护的，如果代码块执行期间发生了异常，控制会传到 `rescue` 和 `end` 之间的块。对于 `begin` 块中的每个 `rescue` 子句，Ruby 把抛出的异常与每个参数进行轮流对比，如果 `rescue` 子句中命名的异常与当前抛出异常的类型相同，或者是该异常的父类，则匹配成功；如果异常不匹配所有指定的错误类型，可以在所有的 `rescue` 子句后使用一个 `else` 子句。

#### 1.22.1. retry 语句

​	可以使用 `rescue` 块捕获异常，然后使用 `retry` 语句从开头开始执行 `begin` 块。

```ruby
begin
  ...
rescue
  # 把控制移到 begin 的开头
  retry
end
```

**注意**：如果没有结束 `retry` 的控制，那么代码可能陷入死循环，所以处理异常时，谨慎使用 `retry`。

#### 1.22.2. raise 语句

​	可以使用 `raise` 语句抛出异常。

```ruby
# 重新抛出当前异常，没有则抛出 RuntimeError
raise
# 创建一个 RuntimeError 异常，并设置错误信息
raise "Error Message"
# 创建一个指定异常类型，并设置错误信息
raise ExceptionType, "Error Message"
# 添加异常抛出的条件语句，满足时，抛出指定类型、信息的异常
raise ExceptionType, "Error Message" condition
```

#### 1.22.3. ensure 语句

​	无论是否抛出异常，`ensure` 语句会在代码块结束时完成。`ensure` 放在最后一个 `rescue` 子句后，并包含一个块终止时总是执行的代码块。

#### 1.22.4. else 语句

​	`else` 语句只有在代码主体没有抛出异常时执行。一般放置在所有 `rescue` 子句之后，`ensure` 子句之前。

#### 1.22.5. Catch & Throw

​	`raise` 和 `rescue` 的异常机制在发生错误时放弃执行，`catch` 和 `throw` 用于需要在正常处理时跳出一些深层嵌套结构的操作。

​	`catch` 定义了一个使用给定的名称作为标签的块，代码块正常执行，直到 `throw` 一个与之同名的标签，退出 `catch` 块。

#### 1.22.6. 类 Exception

​	Ruby 的所有异常类均来自于 Exception，Exception 内建的子类等级见 [Document for Ruby](https://docs.ruby-lang.org/en/master/Exception.html)

## 2. Ruby 高级教程

### 2.1. 面向对象

#### 2.1.1. 类定义

```ruby
class Classname
  ...
end
```

#### 2.1.2. 实例化对象

​	类提供了对象的蓝图，对象基于类的定义创建。

```ruby
instance_name = Classname.new
```

##### initialize 方法

​	`initialize` 方法是一个标准的 Ruby 类方法，是类的构造方法，在调用 `new` 时，会自动调用该方法。

```ruby
def initialize(...)
  ...
end
```

#### 2.1.3. 实例化变量

​	实例变量是类的属性，它们在使用类创建对象时，成为对象的属性。一般情况下，不同的对象具有不同的属性，这些属性单独赋值，并和其他对象不共享。对一个对象内部而言，任何方法可以使用 `@` 运算符访问这些属性；而对于外部而言，属性不可见，需要定义公共方法访问内部属性。

```ruby
def initialize (var1, var2, ... , *args)
  @var1, @var2, ... = var1, var2, ...
end
```

#### 2.1.4. 访问器 & 设置器方法

​	为了在类的外部读取类中已定义的变量，可以通过定义访问器方法来访问。具体可以通过设置方法的返回值为类的属性。与访问变量值类似，Ruby 提供了一种在类的外部将参数传入类中已定义的变量，也就是所谓的设置器方法。

​	这两种方法非常常用，因此 Ruby 定义了 `attr_accessor :var`、`attr_reader :var`、`attr_writer :var` 三种属性声明方法。使用时可以调用与属性同名的方法，相应的读取或者写入属性。

```ruby
class Classname
  attr_accessor :var
end

classinstance = Classname.new
classinstance.var = ...
```

#### 2.1.5. 实例方法

​	实例方法的定义与其他方法的定义一样，都是使用 `def` 关键字，但是它们只能通过类实例来使用。

```ruby
class Classname
  # 实例方法
  def methodname
    # method_body
  end
end
```

#### 2.1.6. 类方法 & 类变量

​	类变量是类的所有实例中共享的变量，类变量的实例可以被所有对象实例访问。类变量以 `@@` 作为前缀，类变量必须在类定义中被初始化，且必须使用自定义方法访问，`attr_*` 无法访问。

​	类方法使用 `def self.methodname()` 定义，类方法以 `end` 分隔符结尾。类方法可使用带有类名称的 `Classname.methodname` 形式调用。

#### 2.1.7. to_s 方法

​	定义的任何类都有一个 `to_s` 实例方法来返回对象的字符串表示形式。当对象需要以字符串显示时，自动调用该方法。

```ruby
class Classname
  def to_s
    "..."
  end
end

classinstance = Classname.new
puts "#{classinstance}"
```

#### 2.1.8. 访问控制

​	Ruby 提供了三个级别的实例方法保护，分别是 `public`、`private`、`protected` 。Ruby 不在实例和类变量上应用任何访问控制。

- `public`：可被任何对象调用。默认情况下，方法都是 `public` 的，除了 `initialize` 方法总是 `private`；
- `private`：不能从类外部访问或查看，只有类方法可以访问私有成员；
- `protected`：只能被类及其子类的对象调用，访问也只能在类及其子类内部进行。

```ruby
protected :methodname
```

#### 2.1.9. 类的继承

Ruby 提供了子类化的概念，只要添加一个 `<` 字符和父类名称到类语句即可。

```ruby
class Derivedclass < Baseclass
  # class define
end
```

#### 2.1.10. 方法重载

​	虽然可以在派生类中添加新的功能，但是有时可能想要改变已经在父类中定义的方法的行为。这时可以保持方法名称不变，重载方法的功能即可。

```ruby
class Baseclass
  def method1
    # method define
  end
end

class Derivedclass < Baseclass
  def method1
    # overload
  end
end
```

#### 2.1.11. 运算符重载

​	在对象运算时，有时需要将运算符重载运算规则。

```ruby
class Operator
  def +(addend)
    # add define
  end
  
  def -(subtractor)
    # subtract define
  end
  
  def *(factor)
    # multiple define
  end
end
```

#### 2.1.12. 冻结对象

​	如果需要防止对象被改变，在 Object 中，`freeze` 方法可以实现这点，它能有效地把一个对象变成一个常数。任何对象都可以通过调用 `Object.freeze` 进行冻结。冻结对象不能被修改。

​	可以使用 `Object.frozen?` 检查一个给定的对象是否被冻结。如果对象已经被冻结，则该方法返回 `true` ，否则返回一个 `false` 。

#### 2.1.13. 类常量

​	可以在类内部定义一个常量，通过把一个直接的数值或字符串赋给一个变量来定义，变量的定义不需要使用 `@` 或 `@@` ，按照惯例，常量名称使用全大写。

​	一旦常量被定义，就不能改变它的值，可以在类的内部直接访问常量，就像是访问变量一样，但是如果想要在类的外部访问常量，必须使用 `Classname::CONSTANT` 。

```ruby
class Classname
  CONSTANT = 0
end

puts Classname::CONSTANT
```

#### 2.1.14. allocate 创建对象

​	如果想要在不调用对象构造器 `initialize` 的情况下创建对象，即不使用 `new` 方法创建对象，在这种情况下，可以调用 `allocate` 来创建一个未初始化的对象，需要手动初始化变量。

#### 2.1.15. 类信息

​	Ruby 的 `self` 和 Java 的 `this` 有相似之处，但又大不相同。Java 的方法都是在实例方法中引用，所以 `this` 一般都是指向当前对象的。而 Ruby 的代码逐行执行，所以在不同的上下文，`self` 就有了不同的含义。

```ruby
class Classname
  # self.class = class
  puts self.class
  # self.name = Classname
  puts self.name
end
```

​	这意味着，类在定义时，将该类看作元类 `class` 的对象来执行，同时也意味着，元类和父类中的该方法在方法定义执行期间是可用的。

### 2.2. 正则表达式

​	正则表达式是一种特殊序列的字符，它通过使用又专门语法的模式来匹配或查找字符串集合。

#### 2.2.1. 语法

​	正则表达式从字面上看是一种介于 `/` 之间的或介于跟在 `%r` 后的任意分隔符之间的模式。

```ruby
/pattern/
/pattern/im					# 指定匹配时选项
%r !/usr/local/!    # 使用 ! 分隔的正则表达式，用于匹配带有 \/ 的字符串
```

#### 2.2.2. 修饰符

| 修饰符          | 描述                                                         |
| :-------------- | :----------------------------------------------------------- |
| `i`             | 当匹配文本时忽略大小写                                       |
| `o`             | 只执行一次 `#{}` 插值，正则表达式在第一次时就进行判断        |
| `x`             | 忽略空格，允许在整个表达式中放入空白符和注释                 |
| `m`             | 匹配多行，把换行字符识别为正常字符                           |
| `u` `e` `s` `n` | 把正则表达式解释为 Unicode（UTF-8）、EUC、SJIS 或 ASCII（如果没有指定修饰符，则认为正则表达式使用的是源编码） |

#### 2.2.3. 模式匹配

​	详细内容查看官方文档 [class Regexp](https://docs.ruby-lang.org/en/master/Regexp.html) 。

#### 2.3. 连接 MySQL - mysql2

​	Ruby 连接 MySQL 的高效驱动 mysql2 。

```shell
gem install mysql2
```

#### 2.3.1. 连接

```ruby
client = Mysql2::Client.new(:host => "localhost", :username => "root")
```

#### 2.3.2. 查询

```ruby
results = client.query("SELECT * FORM users;")
```

#### 2.3.3. 迭代结果集

```ruby
results.each do |row|
  puts row["id"]
end
```

#### 2.3.4. 其他

​	详细的使用方法查看 Gem 官方文档 [Mysql2](https://www.rubydoc.info/gems/mysql2) 。

















































































