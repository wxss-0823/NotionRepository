## C++ 学习笔记

### C++ 教程

#### 1.  数据类型

##### 基本的内置类型

| 类型     | 关键字  |
| :------- | :------ |
| 布尔型   | bool    |
| 字符型   | char    |
| 整型     | int     |
| 浮点型   | float   |
| 双浮点型 | double  |
| 无类型   | void    |
| 宽字符型 | wchar_t |

##### typeof 声明

```c++
typedef type newname; 
```

##### 枚举类型

```c++
enum 枚举名{ 
     标识符[=整型常数], 
     标识符[=整型常数], 
... 
    标识符[=整型常数]
} 枚举变量;
```

- 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。

- 也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。

##### 类型转换

类型转换是将一个数据类型的值转换为另一种数据类型的值。

###### 静态转换（Static Cast）

- 静态转换是将一种数据类型的值强制转换为另一种数据类型的值。
- 静态转换通常用于比较类型相似的对象之间的转换，例如将 int 类型转换为 float 类型。
- 静态转换不进行任何运行时类型检查，因此可能会导致运行时错误。

###### 动态转换（Dynamic Cast）

- 动态转换通常用于将一个基类指针或引用转换为派生类指针或引用。
- 动态转换在运行时进行类型检查，如果不能进行转换则返回空指针或引发异常。

###### 常量转换（Const Cast）

- 常量转换用于将 const 类型的对象转换为非 const 类型的对象。

###### 重新解释转换（Reinterpret Cast）

- 重新解释转换将一个数据类型的值重新解释为另一个数据类型的值，通常用于在不同的数据类型之间进行转换。

- 重新解释转换不进行任何类型检查，因此可能会导致未定义的行为。

#### 2.  变量类型

1. 整数类型（Integer Types）：
   - `int`：用于表示整数，通常占用4个字节。
   - `short`：用于表示短整数，通常占用2个字节。
   - `long`：用于表示长整数，通常占用4个字节。
   - `long long`：用于表示更长的整数，通常占用8个字节。
2. 浮点类型（Floating-Point Types）：
   - `float`：用于表示单精度浮点数，通常占用4个字节。
   - `double`：用于表示双精度浮点数，通常占用8个字节。
   - `long double`：用于表示更高精度的浮点数，占用字节数可以根据实现而变化。
3. 字符类型（Character Types）：
   - `char`：用于表示字符，通常占用1个字节。
   - `wchar_t`：用于表示宽字符，通常占用2或4个字节。
   - `char16_t`：用于表示16位Unicode字符，占用2个字节。
   - `char32_t`：用于表示32位Unicode字符，占用4个字节。
4. 布尔类型（Boolean Type）：
   - `bool`：用于表示布尔值，只能取`true`或`false`。
5. 枚举类型（Enumeration Types）：
   - `enum`：用于定义一组命名的整数常量。
6. 指针类型（Pointer Types）：
   - `type*`：用于表示指向类型为`type`的对象的指针。
7. 数组类型（Array Types）：
   - `type[]`或`type[size]`：用于表示具有相同类型的元素组成的数组。
8. 结构体类型（Structure Types）：
   - `struct`：用于定义包含多个不同类型成员的结构。
9. 类类型（Class Types）：
   - `class`：用于定义具有属性和方法的自定义类型。
10. 共用体类型（Union Types）：
    - `union`：用于定义一种特殊的数据类型，它可以在相同的内存位置存储不同的数据类型。

##### 变量定义

```c++
type variable_list;
```

##### 变量声明

变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

##### 左值（Lvalues）和右值（Rvalues）

- **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。
- **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。

#### 3.  变量作用域

- **局部作用域**：在函数内部声明的变量具有局部作用域，它们只能在函数内部访问。局部变量在函数每次被调用时被创建，在函数执行完后被销毁。
- **全局作用域**：在所有函数和代码块之外声明的变量具有全局作用域，它们可以被程序中的任何函数访问。全局变量在程序开始时被创建，在程序结束时被销毁。
- **块作用域**：在代码块内部声明的变量具有块作用域，它们只能在代码块内部访问。块作用域变量在代码块每次被执行时被创建，在代码块执行完后被销毁。
- **类作用域**：在类内部声明的变量具有类作用域，它们可以被类的所有成员函数访问。类作用域变量的生命周期与类的生命周期相同。

#### 4.  常量

- 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做**字面量**。

- 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。

- 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

##### 整数常量

- 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。

- 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

##### 浮点常量

- 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

- 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

##### 布尔常量

- **true** 值代表真。
- **false** 值代表假。

##### 字符常量

字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L'x'），此时它必须存储在 **wchar_t** 类型的变量中。否则，它就是一个窄字符常量（例如 'x'），此时它可以存储在 **char** 类型的简单变量中。

##### 字符串常量

字符串字面值或常量是括在双引号 **""** 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

您可以使用 `\` 做分隔符，把一个很长的字符串常量进行分行。

##### 定义常量

###### #define 预处理器

```
#define identifier value
```

###### const 关键字

```
const type variable = value;
```

#### 5.  修饰符类型

C++ 允许在 **char、int 和 double** 数据类型前面放置修饰符。

- signed：表示变量可以存储负数。对于整型变量来说，signed 可以省略，因为整型变量默认为有符号类型。
- unsigned：表示变量不能存储负数。对于整型变量来说，unsigned 可以将变量范围扩大一倍。
- short：表示变量的范围比 int 更小。short int 可以缩写为 short。
- long：表示变量的范围比 int 更大。long int 可以缩写为 long。
- long long：表示变量的范围比 long 更大。C++11 中新增的数据类型修饰符。
- float：表示单精度浮点数。
- double：表示双精度浮点数。
- bool：表示布尔类型，只有 true 和 false 两个值。
- char：表示字符类型。
- wchar_t：表示宽字符类型，可以存储 Unicode 字符。

##### 类型限定符

| 限定符   | 含义                                                         |
| :------- | :----------------------------------------------------------- |
| const    | **const** 定义常量，表示该变量的值不能被修改。               |
| volatile | 修饰符 **volatile** 告诉该变量的值可能会被程序以外的因素改变，如硬件或其他线程。。 |
| restrict | 由 **restrict** 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 |
| mutable  | 表示类中的成员变量可以在 const 成员函数中被修改。            |
| static   | 用于定义静态变量，表示该变量的作用域仅限于当前文件或当前函数内，不会被其他文件或函数访问。 |
| register | 用于定义寄存器变量，表示该变量被频繁使用，可以存储在CPU的寄存器中，以提高程序的运行效率。 |

#### 6.  存储类

存储类定义程序中变量或函数的范围（可见性）和生命周期。

- static
- extern
- mutable
- thread_local (C++11)

##### static 存储类

- **static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

- static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

##### extern 存储类

- **extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 'extern' 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

##### mutable 存储类

- 仅适用于类的成员变量和lambda表达式中。

- mutabel是专门为突破const限制而设定，const修饰的成员函数无法修改成员变量（可查看），被mutabel修饰的成员变量可被const成员函数修改。

- const修饰成员函数放在后面，形式如 `int f() const;` 放在前面则表示函数返回值不可变。

##### thread_local 存储类

- 仅能修饰变量，不可修饰函数。

- 每个独立的线程不共享这个变量，每次使用都初始化。

- 生存周期为线程的生存周期。

- 修饰局部变量时，生存周期同样为线程周期，不随函数结束而释放。

#### 7.  运算符

- 算术运算符
- 关系运算符
- 逻辑运算符
- 位运算符
- 赋值运算符
- 杂项运算符

#### 8.  循环

##### 循环类型

| 循环类型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [while 循环](https://www.runoob.com/cplusplus/cpp-while-loop.html) | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 |
| [for 循环](https://www.runoob.com/cplusplus/cpp-for-loop.html) | 多次执行一个语句序列，简化管理循环变量的代码。               |
| [do...while 循环](https://www.runoob.com/cplusplus/cpp-do-while-loop.html) | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。    |
| [嵌套循环](https://www.runoob.com/cplusplus/cpp-nested-loops.html) | 您可以在 while、for 或 do..while 循环内使用一个或多个循环。  |

##### 循环控制语句

| 控制语句                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [break 语句](https://www.runoob.com/cplusplus/cpp-break-statement.html) | 终止 **loop** 或 **switch** 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 |
| [continue 语句](https://www.runoob.com/cplusplus/cpp-continue-statement.html) | 引起循环跳过主体的剩余部分，立即重新开始测试条件。           |
| [goto 语句](https://www.runoob.com/cplusplus/cpp-goto-statement.html) | 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 |

##### 无限循环

```c++
for( ; ; )
```

#### 9.  判断

##### 判断语句

| 语句                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [if 语句](https://www.runoob.com/cplusplus/cpp-if.html)      | 一个 **if 语句** 由一个布尔表达式后跟一个或多个语句组成。    |
| [if...else 语句](https://www.runoob.com/cplusplus/cpp-if-else.html) | 一个 **if 语句** 后可跟一个可选的 **else 语句**，else 语句在布尔表达式为假时执行。 |
| [嵌套 if 语句](https://www.runoob.com/cplusplus/cpp-nested-if.html) | 您可以在一个 **if** 或 **else if** 语句内使用另一个 **if** 或 **else if** 语句。 |
| [switch 语句](https://www.runoob.com/cplusplus/cpp-switch.html) | 一个 **switch** 语句允许测试一个变量等于多个值时的情况。     |
| [嵌套 switch 语句](https://www.runoob.com/cplusplus/cpp-nested-switch.html) | 您可以在一个 **switch** 语句内使用另一个 **switch** 语句。   |

##### ? : 运算符

```c++
Exp1 ? Exp2 : Exp3;
```

如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。

#### 10.  函数

##### 定义函数

```c++
return_type function_name( parameter list )
{
   body of the function
}
```

- **返回类型：**一个函数可以返回一个值。**return_type** 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 **void**。
- **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。
- **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
- **函数主体：**函数主体包含一组定义函数执行任务的语句。

##### 函数声明

函数**声明**会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

```c++
return_type function_name( parameter list );
```

##### 调用函数

当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。

##### 函数参数

| 调用类型                                                     | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [传值调用](https://www.runoob.com/cplusplus/cpp-function-call-by-value.html) | 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 |
| [指针调用](https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html) | 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |
| [引用调用](https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html) | 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 |

##### 参数的默认值

定义一个函数，可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。

##### Lambda 函数与表达式

```c++
[capture](parameters)->return-type{body}
```

```c++
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```

#### 11.  数字

##### 数学运算

| 序号 | 函数 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **double cos(double);** 该函数返回弧度角（double 型）的余弦。 |
| 2    | **double sin(double);** 该函数返回弧度角（double 型）的正弦。 |
| 3    | **double tan(double);** 该函数返回弧度角（double 型）的正切。 |
| 4    | **double log(double);** 该函数返回参数的自然对数。           |
| 5    | **double pow(double, double);** 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 |
| 6    | **double hypot(double, double);** 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 |
| 7    | **double sqrt(double);** 该函数返回参数的平方根。            |
| 8    | **int abs(int);** 该函数返回整数的绝对值。                   |
| 9    | **double fabs(double);** 该函数返回任意一个浮点数的绝对值。  |
| 10   | **double floor(double);** 该函数返回一个小于或等于传入参数的最大整数。 |

##### 随机数

在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 **rand()**，该函数只返回一个伪随机数。生成随机数之前必须先调用 **srand()** 函数。

#### 12.  数组

##### 声明数组

```c++
type arrayName [ arraySize ];
```

##### 初始化数组

大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。

如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。

##### 访问数组元素

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。

##### 数组详解

| 概念                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [多维数组](https://www.runoob.com/cplusplus/cpp-multi-dimensional-arrays.html) | C++ 支持多维数组。多维数组最简单的形式是二维数组。           |
| [指向数组的指针](https://www.runoob.com/cplusplus/cpp-pointer-to-an-array.html) | 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 |
| [传递数组给函数](https://www.runoob.com/cplusplus/cpp-passing-arrays-to-functions.html) | 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 |
| [从函数返回数组](https://www.runoob.com/cplusplus/cpp-return-arrays-from-function.html) | C++ 允许从函数返回数组。                                     |

#### 13.  字符串

##### String 类

**string** 类类型，支持 C 语言中所有的操作，另外还增加了其他更多的功能。

#### 14.  指针（*）

##### 变量声明

```c++
type *var-name;
```

##### 使用指针

使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。

##### 函数指针

- 定义了指向特定类型的函数的指针，括号不能省略。

```c++
typename (*pointer)(typename variable1, ...);
```

- 也可以使用 **typedef** 定义指向某种函数的函数指针类。

```c++
typedef typename (*classname)(typename variable1, ...);
classname example;	// 实例化函数指针类
```



##### 指针详解

| 概念                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [C++ Null 指针](https://www.runoob.com/cplusplus/cpp-null-pointers.html) | C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 |
| [C++ 指针的算术运算](https://www.runoob.com/cplusplus/cpp-pointer-arithmetic.html) | 可以对指针进行四种算术运算：++、--、+、-                     |
| [C++ 指针 vs 数组](https://www.runoob.com/cplusplus/cpp-pointers-vs-arrays.html) | 指针和数组之间有着密切的关系。                               |
| [C++ 指针数组](https://www.runoob.com/cplusplus/cpp-array-of-pointers.html) | 可以定义用来存储指针的数组。                                 |
| [C++ 指向指针的指针](https://www.runoob.com/cplusplus/cpp-pointer-to-pointer.html) | C++ 允许指向指针的指针。                                     |
| [C++ 传递指针给函数](https://www.runoob.com/cplusplus/cpp-passing-pointers-to-functions.html) | 通过引用或地址传递参数，使传递的参数在调用函数中被改变。     |
| [C++ 从函数返回指针](https://www.runoob.com/cplusplus/cpp-return-pointer-from-functions.html) | C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。     |

#### 15.  引用（&）

引用变量是一个别名，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

##### 引用 vs 指针

- 不存在空引用。引用必须连接到一块合法的内存。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。
- 引用必须在创建时被初始化。指针可以在任何时间被初始化。

##### 创建引用

变量名称是变量附属在内存位置中的标签，可以把引用当成是变量附属在内存位置中的第二个标签。

```c++
int i = 17;
/* 创建变量 i 的一个引用 r */
int&  r = i;
```

| 概念                                                         | 描述                                                     |
| :----------------------------------------------------------- | :------------------------------------------------------- |
| [把引用作为参数](https://www.runoob.com/cplusplus/passing-parameters-by-references.html) | C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 |
| [把引用作为返回值](https://www.runoob.com/cplusplus/returning-values-by-reference.html) | 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。    |

#### 16.  日期 & 时间

为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 `<ctime>` 头文件。

有四个与时间相关的类型：**clock_t、time_t、size_t** 和 **tm**。

- 类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。

- 结构类型 **tm** 把日期和时间以 C 结构的形式保存。

  ```c++
  struct tm {
    int tm_sec;   // 秒，正常范围从 0 到 59，但允许至 61
    int tm_min;   // 分，范围从 0 到 59
    int tm_hour;  // 小时，范围从 0 到 23
    int tm_mday;  // 一月中的第几天，范围从 1 到 31
    int tm_mon;   // 月，范围从 0 到 11
    int tm_year;  // 自 1900 年起的年数
    int tm_wday;  // 一周中的第几天，范围从 0 到 6，从星期日算起
    int tm_yday;  // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起
    int tm_isdst; // 夏令时
  };
  ```

##### 日期 & 时间的重要函数

| 序号 | 函数 & 描述                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | [**time_t time(time_t \*time);**](https://www.runoob.com/cplusplus/c-function-time.html) 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 -1。 |
| 2    | [**char \*ctime(const time_t \*time);**](https://www.runoob.com/cplusplus/c-function-ctime.html) 该返回一个表示当地时间的字符串指针，字符串形式 *day month year hours:minutes:seconds year\n\0*。 |
| 3    | [**struct tm \*localtime(const time_t \*time);**](https://www.runoob.com/cplusplus/c-function-localtime.html) 该函数返回一个指向表示本地时间的 **tm** 结构的指针。 |
| 4    | [**clock_t clock(void);**](https://www.runoob.com/cplusplus/c-function-clock.html) 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 -1。 |
| 5    | [**char \* asctime ( const struct tm \* time );**](https://www.runoob.com/cplusplus/c-function-asctime.html) 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\n\0。 |
| 6    | [**struct tm \*gmtime(const time_t \*time);**](https://www.runoob.com/cplusplus/c-function-gmtime.html) 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 |
| 7    | [**time_t mktime(struct tm \*time);**](https://www.runoob.com/cplusplus/c-function-mktime.html) 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 |
| 8    | [**double difftime ( time_t time2, time_t time1 );**](https://www.runoob.com/cplusplus/c-function-difftime.html) 该函数返回 time1 和 time2 之间相差的秒数。 |
| 9    | [**size_t strftime();**](https://www.runoob.com/cplusplus/c-function-strftime.html) 该函数可用于格式化日期和时间为指定的格式。 |

#### 17.  基本的输入输出

##### I/O 库头文件

| 头文件     | 函数和描述                                                   |
| :--------- | :----------------------------------------------------------- |
| <iostream> | 该文件定义了 **cin、cout、cerr** 和 **clog** 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 |
| <iomanip>  | 该文件通过所谓的参数化的流操纵器（比如 **setw** 和 **setprecision**），来声明对执行标准化 I/O 有用的服务。 |
| <fstream>  | 该文件为用户控制的文件处理声明服务。                         |

##### 标准输出流（cout）

预定义的对象 **cout** 是 **iostream** 类的一个实例。cout 对象"连接"到标准输出设备，通常是显示屏。**cout** 是与流插入运算符 << 结合使用的。

##### 标准输入流（cin）

预定义的对象 **cin** 是 **iostream** 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。**cin** 是与流提取运算符 >> 结合使用的。

##### 标准错误流（cerr）

预定义的对象 **cerr** 是 **iostream** 类的一个实例。cerr 对象附属到标准输出设备，通常也是显示屏，但是 **cerr** 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。**cerr** 也是与流插入运算符 << 结合使用的。

##### 标准日志流（clog）

预定义的对象 **clog** 是 **iostream** 类的一个实例。clog 对象附属到标准输出设备，通常也是显示屏，但是 **clog** 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。**clog** 也是与流插入运算符 << 结合使用的，

#### 18.  数据结构

##### 定义结构

```c++
struct type_name {
member_type1 member_name1;
member_type2 member_name2;
member_type3 member_name3;
.
.
} object_names;
```

##### 结构体初始化

- 使用结构体名 + ()：不需要具体变量名实例化结构体。

##### 访问结构成员

使用**成员访问运算符（.）**访问结构成员。成员访问运算符是结构变量名称和要访问的结构成员之间的一个句号。

##### 结构作为函数参数

可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。

##### 指向结构的指针

```c++
struct Books *struct_pointer;
```

##### typedef 关键字

```c++
typedef struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
}Books;
```

- 可以直接使用 *Books* 来定义 *Books* 类型的变量，而不需要使用 struct 关键字。

### C++ 面向对象

#### 1.  类 & 对象

##### 类定义

- 定义一个类需要使用关键字 **class**，然后指定类的名称，并类的主体是包含在一对花括号中，主体包含类的成员变量和成员函数。

- 定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。

##### 定义对象

- 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。

##### 访问数据成员

- 类的对象的公共数据成员可以使用直接成员访问运算符 `.` 来访问。

##### 类成员函数

- 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。

- 成员函数可以定义在类定义内部，或者单独使用**范围解析运算符 ::** 来定义。在类定义中定义的成员函数把函数声明为**内联**的，即便没有使用 inline 标识符。

##### 类访问修饰符

类成员的访问限制是通过在类主体内部对各个区域标记 **public、private、protected** 来指定的。关键字 **public、private、protected** 称为访问修饰符。

- 公有（public）成员：**公有**成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值，

- 私有（private）成员：**私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。

- protected（受保护）成员：**protected（受保护）**成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。

###### 继承中的特点

- **public 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
- **protected 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
- **private 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private

##### 类构造函数 & 析构函数

###### 类的构造函数

- 类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

- 构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。

###### 使用初始化列表来初始化字段

```c++
classname::classname( double a, double b, double c): X(a), Y(b), Z(c)
{
  ....
}
```

###### 类的析构函数

- 类的**析构函数**是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。

- 析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。

##### 拷贝构造函数

是一种特殊的构造函数，可以理解为拷贝对象时调用的构造函数。默认的拷贝构造函数仅涉及简单的赋值，涉及指针变量，动态内存分配等，需要自行定义拷贝构造函数。

- 通过使用一个同类型的对象来初始化新创建的对象。
- 复制对象把它作为参数传递给函数。
- 复制对象，并从函数返回这个对象。

```c++
classname (const classname &obj) {
   // 构造函数的主体
}
```

##### 友元函数

- 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

- 友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

- 如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 **friend**。

- 声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如下声明：

  ```c++
  friend class ClassTwo;
  ```

##### 内联函数

- **内联函数**是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

##### this 指针

- **this** 指针是一个特殊的指针，它指向当前对象的实例。

- **this**是一个隐藏的指针，可以在类的成员函数中使用，它可以用来指向调用对象。

- 当一个对象的成员函数被调用时，编译器会隐式地传递该对象的地址作为 this 指针。

##### 指向类的指针

- 访问指向类的指针的成员，需要使用成员访问运算符 **->**，就像访问指向结构的指针一样。与所有的指针一样，必须在使用指针之前，对指针进行初始化。

##### 类的静态成员

- 使用 **static** 关键字来把类成员定义为静态的。当声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。

- 静态成员在类的所有对象中是共享的。如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 **::** 来重新声明静态变量从而对它进行初始化，

###### 静态成员函数

- 如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，**静态函数**只要使用类名加范围解析运算符 **::** 就可以访问。

- 静态成员函数只能访问**静态成员数据**、其他静态成员函数和类外部的其他函数。

- 静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。

###### 静态成员函数与普通成员函数的区别：

- 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。
- 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。

##### 函数类

一个函数类，即一个重载了括号操作符`()`的类。

- 该类名 + `()` ：作用等价于重载操作函数。
- 该类的对象叫做函数对象。

#### 2.  继承

当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**。

##### 基类 & 派生类

一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名。

```c++
class derived-class: access-specifier base-class
```

##### 访问控制和继承

| 访问     | public | protected | private |
| :------- | :----- | :-------- | :------ |
| 同一个类 | yes    | yes       | yes     |
| 派生类   | yes    | yes       | no      |
| 外部的类 | yes    | no        | no      |

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

##### 继承类型

- **公有继承（public）：**当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。
- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
- **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

##### 多继承

多继承即一个子类可以有多个父类，它继承了多个父类的特性。

```c++
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
```

#### 3.  重载运算符和重载函数

- 同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。

- 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

##### 函数重载

同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。

##### 运算符重载

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。

```c++
Box operator+(const Box&);
```

如果定义上面的函数为类的非成员函数，那么需要为每次操作传递两个参数。

```c++
Box operator+(const Box&, const Box&);
```

#### 4.  多态

**多态**按字面的意思就是多种形态。可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。

##### 虚函数

**虚函数** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。

- 在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

##### 纯虚函数

需要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

```c++
// pure virtual function
virtual int area() = 0;
```

#### 5.  数据抽象

数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。

##### 访问标签强制抽象

- 使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。
- 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。

##### 数据抽象的好处

- 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。
- 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。

#### 6.  数据封装

- **程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。
- **程序数据：**数据是程序的信息，会受到程序函数的影响。

封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即**数据隐藏**。

**数据封装**是一种把数据和操作数据的函数捆绑在一起的机制，**数据抽象**是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。

C++ 通过创建**类**来支持封装和数据隐藏（public、protected、private）。类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。

#### 7.  接口（抽象类）

接口描述了类的行为和功能，而不需要完成类的特定实现。

- C++ 接口是使用**抽象类**来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。
- 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 "= 0" 来指定的。
- 设计**抽象类**（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为**接口**使用。如果试图实例化一个抽象类的对象，会导致编译错误。
- 当一个 ABC 的子类需要被实例化，则必须实现每个纯虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。
- 可用于实例化对象的类被称为**具体类**。

### C++ 高级教程

#### 1.  文件和流

| 数据类型 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| ofstream | 该数据类型表示输出文件流，用于创建文件并向文件写入信息。     |
| ifstream | 该数据类型表示输入文件流，用于从文件读取信息。               |
| fstream  | 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 |

##### 打开文件

```c++
void open(const char *filename, ios::openmode mode);
```

| 模式标志   | 描述                                                         |
| :--------- | :----------------------------------------------------------- |
| ios::app   | 追加模式。所有写入都追加到文件末尾。                         |
| ios::ate   | 文件打开后定位到文件末尾。                                   |
| ios::in    | 打开文件用于读取。                                           |
| ios::out   | 打开文件用于写入。                                           |
| ios::trunc | 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 |

##### 关闭文件

```c++
void close();
```

##### 写入文件

使用流插入运算符（ << ）向文件写入信息。

##### 读取文件

使用流提取运算符（ >> ）从文件读取信息。

##### 文件位置指针

**istream** 和 **ostream** 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 **seekg**（"seek get"）和关于 ostream 的 **seekp**（"seek put"）。

seekg 和 seekp 的第一个参数通常是一个长整型，第二个参数可以用于指定查找方向。

- 第一个参数指定了从文件的查找位置到指针所在位置的字节数。

- 查找方向可以是 **ios::beg**（默认的，从流的开头开始定位），也可以是 **ios::cur**（从流的当前位置开始定位），也可以是 **ios::end**（从流的末尾开始定位）。

```c++
// 指针定位于文件开始，并向后偏移 n 个字节。
fileObject.seekg(n, ios::beg);
```

#### 2.  异常处理

- **throw:** 当问题出现时，程序会抛出一个异常。这是通过使用 **throw** 关键字来完成的。
- **catch:** 在您想要处理问题的地方，通过异常处理程序捕获异常。**catch** 关键字用于捕获异常。
- **try:** **try** 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。

```c++
try
{
   // 保护代码
}catch( ExceptionName e1 )
{
   // catch 块
}catch( ExceptionName e2 )
{
   // catch 块
}catch( ExceptionName eN )
{
   // catch 块
}
```

##### 抛出异常

可以使用 **throw** 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。

```c++
throw "Division by zero condition!";
```

##### 捕获异常

**catch** 块跟在 **try** 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。

```c++
catch( ExceptionName e )
```

##### 定义新的异常

可以通过继承和重载 **exception** 类来定义新的异常。

#### 3.  动态内存

- **栈：**在函数内部声明的所有变量都将占用栈内存。
- **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。

##### new 和 delete 运算符

```c++
new data-type;		  // 使用 new 为类型动态分配地址
```

```c++
delete pvalue;        // 释放 pvalue 所指向的内存
delete [] pvalue;	  // 若 pvalue 指向数组，在 pvalue 前放置空括号
```

##### 数组的动态内存分配

```c++
char* pvalue  = NULL;   // 初始化为 null 的指针
pvalue  = new char[20]; // 为变量请求内存
delete [] pvalue;        // 删除 pvalue 所指向的数组
```

#### 4.  命名空间

##### 定义命名空间

```c++
namespace namespace_name {
   // 代码声明
}
```

##### 调用带有命名空间的成员

```c++
name::code;  // code 可以是变量或函数
```

##### using 指令

可以使用 **using namespace** 指令。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。也可以用来指定命名空间中的特定项目。

```c++
using namespace std;		// std 命名空间内的全部成员
using std::cout;			// std 命名空间内的 cout
```

##### 不连续的命名空间

命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素。

##### 嵌套的命名空间

命名空间可以嵌套，可以在一个命名空间中定义另一个命名空间。

通过使用 `::` 运算符来访问嵌套的命名空间中的成员

#### 5.  模板

##### 函数模板

```c++
template <typename type> 
ret-type func-name(parameter list)
{
   // 函数的主体
}
```

- **type** 是函数所使用的数据类型的占位符名称。

##### 类模板

```c++
template <class type> 
class class-name 
{
	...
}
```

- 使用 `<type>` 提供模板的参数。

#### 6.  预处理器

预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。

##### #define 预处理

\#define 预处理指令用于创建符号常量。该符号常量通常称为**宏**。

```c++
#define macro-name replacement-text 
```

##### 参数宏

可以使用 #define 来定义一个带有参数的宏，达到类似函数的效果。

```c++
#define MIN(a,b) (a<b ? a : b)
```

##### 条件编译

可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。

```c++
#ifdef NULL			// 如果定义了 NULL
   #define NULL 0	// 执行语句
#endif
```

##### # 和 ## 运算符

- **#**：会把 replacement-text 令牌转换为用引号引起来的字符串。
- **##**：会把两个令牌连接起来作为一个新的令牌使用。

##### 预定义的宏

| 宏        | 描述                                                         |
| :-------- | :----------------------------------------------------------- |
| \__LINE__ | 这会在程序编译时包含当前行号。                               |
| \__FILE__ | 这会在程序编译时包含当前文件名。                             |
| \__DATE__ | 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 |
| \__TIME__ | 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 |

#### 7.  信号处理

| 信号    | 描述                                         |
| :------ | :------------------------------------------- |
| SIGABRT | 程序的异常终止，如调用 **abort**。           |
| SIGFPE  | 错误的算术运算，比如除以零或导致溢出的操作。 |
| SIGILL  | 检测非法指令。                               |
| SIGINT  | 程序终止(interrupt)信号。                    |
| SIGSEGV | 非法访问内存。                               |
| SIGTERM | 发送到程序的终止请求。                       |

##### signal() 函数

```c++
void __cdecl *signal(int sig, int (*func)(int, int));
```

- __cdecl：调用约定
- `sig` ：信号值。
- `func` ：指向要执行的函数的指针。 第一个参数是信号值，第二个参数是可在第一个参数为`SIGFPE`时使用的子代码。
- `signal` ：返回与给定信号关联的函数的上一个值。该返回值也是一个指针。

##### raise() 函数

可以使用函数 **raise()** 生成信号，该函数带有一个整数信号编号作为参数。

```c++
int raise (signal sig);
```

#### 8.  多线程

一般情况下，两种类型的多任务处理：**基于进程和基于线程**。

- 基于进程的多任务处理是程序的并发执行。
- 基于线程的多任务处理是同一程序的片段的并发执行。

##### 创建线程

```c++
#include <pthread.h>
pthread_create (thread, attr, start_routine, arg) 
```

- **pthread_create** 创建一个新的线程，并让它可执行。下面是关于参数的说明：

| 参数          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| thread        | 指向线程标识符指针。                                         |
| attr          | 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 |
| start_routine | 线程运行函数起始地址，一旦线程被创建就会执行。               |
| arg           | 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 |

##### 终止线程

```c++
#include <pthread.h>
pthread_exit (status) 
```

##### 向线程传递参数

通过结构传递多个参数。

##### 连接和分离线程

```
pthread_join (threadid, status) 
pthread_detach (threadid) 
```

##### std::thread

**std::thread** **在 \<thread>** 头文件中声明.

###### 创建一个空的 **std::thread** 执行对象。

```
#include<thread>
std::thread thread_object(callable)
```

**callable**：定义 callable 后，将其传递给 **std::thread** 构造函数 **thread_object**。

- 函数指针：指向函数的指针，可以定义，也可以是函数名。
- 函数对象：函数类的对象，函数类是重载 `()` 的类。
- lambda 表达式：匿名函数。

## 实例

### Javid9 C++ 游戏示例

#### 1.  Teris Game

核心问题：如何表示俄罗斯方块的旋转。

思路：创建一个4*4的字符串，存放16位的字符描述物体的形状；对于索引可由x，y确定。

| y/x  |  0   |  1   |  2   |  3   |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  1   |  2   |  3   |
|  1   |  4   |  5   |  6   |  7   |
|  2   |  8   |  9   |  10  |  11  |
|  3   |  12  |  13  |  14  |  15  |

进行旋转操作时，不改变字符串，只改变x，y对字符串的索引方式。例如：字符串描述在索引为10的地方存在一个物体“X”，此时（x，y）=（2，2）；表示在最终的画布上（2，2）的位置存在一个物体；若进行顺时针旋转90°，表示在最终的画布上（1，2）的位置存在一个物体，即完成了旋转的操作。问题在于如何实现从（2，2）到（1，2）的变化。由于索引是不变的，那么无论如何旋转，当索引为10是，字符串总对应“X”，变化的仅仅是x，y与索引的对应关系。

重要之处在于，我们关注的总是x，y的值，而不关心字符串在何处为“X”，如何找到不同旋转时的值是关键，因此通过不同状态下的映射公式，遍历就可以得知字符串为“X”时对应的x，y，即知道了应该画图形的位置。
