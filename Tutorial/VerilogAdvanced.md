# Verilog 高级教程



## 1. 编码风格

### 1.1.

​	信号变量、模块等一定要使用有意义的名字，且信号名称在模块间穿梭时也应该保持不变，以便代码本身就具有清晰的说明信息，增强可读性。

​	当名字单词数量过多时，可以使用 `_` 进行拼接。

​	建议使用单词缩写的方式对信号进行命名，并懂得取舍，避免过长的信号命名。

​	虽然 Verilog 区分大小写，但是建议一般功能模块的名称、端口、信号变量等全部使用小写，`parameter` 使用大写，一些电源、Pad 等特殊端口使用大写。只为编写代码方便，容易区分变量常量，不用考虑大小写不一样但名字相同的信号变量的差异。
​	寄存器变量一般加后缀 `_r` ，延迟打拍的变量加后缀 `_r1` 、`_r2` 等。主要有两大好处，一是 RTL 设计时容易根据变量类型对数据进行操作；二是综合后网表的信号名字经常会改变，加入后缀容易在综合后的网表中找到与 RTL 中对应的信号变量。

​	其他后缀：`_d` 可以表示延迟后的信号，`_t` 可以表示暂时存储的信号，`_n` 可以表示低电平有效的信号，`_s` 可以表示 slave 信号，`_m` 可以表示 master 信号等。

​	避免使用关键字对信号进行命名。

​	文件名保持与设计的 `module` 名字一致，文件内尽量只包含一个设计模块。

### 1.2. 注释

​	每一个设计模块开头，都应该包含文件说明信息，包括版权、模块名字、作者、日期、梗概、修改记录等信息。

```verilog
/**********************************************************
// Copyright 1891.06.02-2017.07.14
// Contact with willrious@sina.com
================ runoob.v ======================
>> Author       : wxss
>> Date         : 2025.09.07
>> Description  : Welcome
>> note         : (1)To 
>>              : (2)My
>> V180121      : World.
************************************************************/
```

​	注释应该精炼的表达出代码所描述的意义，简短的注释在一行语句代码之后添加，过长的注释提前一行书写。

​	注释尽量用英文书写，以保证不同操作系统、不同编辑器下能够正常显示。端口信号中，除一般的时钟和复位信号，其他信号最好也进行注释。

### 1.3. 优化

​	使用圆括号确定程序的优先级或逻辑结构。为避免操作符优先级问题导致设计错误，建议多多使用圆括号。同时，圆括号的巧妙使用有时候优化逻辑综合后的结构。

​	条件语句尽量使用 `case` 语句代替 `if` 语句。当同级别的条件判断语句过多时，使用 `case` 语句综合后的硬件结构，往往比 `if` 语句消耗更少的资源，拥有更好的时序。

​	状态机编写时，尽量使用 3 段式，以保证代码具有良好的整洁性和安全性。

​	系统设计时，尽量采用模块按功能分隔，然后进行模块例化的方法。相比于成千上万行代码都集成在一个文件中，模块分隔有利于团队设计，便于更新维护。

### 1.4. 美观

​	端口信号保证每行一个信号，逗号跟在端口声明之后，并保持逗号对齐。

​	一行代码内容过长时，尽量换行编写，无需使用换行符。

​	尽量使用 `begin` 和 `end` 的方式保证执行语句间的层叠关系，`begin` 与关键字同行，`end` 另起一行。即便在只有一条执行语句时，可以省略 `begin` 和 `end` 关键字，但为保证结构的完整性，以及后续代码的调试与修改，还是建议加入此类关键字。

​	尽量使用 `tab` 键和空格，保证语句按照层级结构对齐，变量、关键字、操作符之间也应该留有空隙，便于逻辑判断。

​	模块例化时，端口信号尽量与连接信号隔开，并各自对齐。连接信号为向量时指明其位宽，方便阅读、调式。例化多个相同的模块时，尽量使用 `generate` 语句，避免过长的例化代码描述。

## 2. 代码规范

### 2.1. 赋初值

​	变量声明时不要对变量进行赋初值操作。如果变量声明时设置初始值，仿真时变量会有期望的初值，但综合后电路的初始值，是不确定的。如果信号初值会影响逻辑功能，则仿真过程可能会因验证不充分而错过查找处逻辑错误的机会。

​	赋初值操作应该在复位状态下完成，也建议寄存器变量都是用复位端，以保证系统商店或紊乱时，可以通过复位操作让系统恢复初始状态。建议设计时，时钟采用正边沿逻辑，复位采用负边沿逻辑。复位时语句块中所有信号都应该赋予初值，不要漏掉相关信号。

###  2.2. always 语句

​	不到万不得已，不要在 2 个 `always` 块中分别使用同一时钟的上升沿和下降沿逻辑，否则会引入相对复杂的时钟质量和时序约束问题。

​	禁止在一个 `always` 块中同时将时钟的双边沿作为触发条件，编译、仿真可能会按照设计人员的思想进行，但此类电路往往不可综合，或综合后电路功能不符合预期。

​	禁止在 2 个 `always` 块中为同一个变量赋值。

​	一个 `always` 块中，不要存在多个并行或不相关的条件语句，使用多个 `always` 分别描述。当一个 `always` 语句中存在多个并行或不相关的条件语句时，仿真的执行结果或综合的实际电路中，不相关的条件语句都是并行执行的。但是仿真结果可能是顺序执行的，如果有延迟，信息可能会导致不可以预知的错误结果。且该写法可读性差，功能结构划分不明显。

### 2.3. 时钟和异步

​	设计中尽量使用同步设计。必须使用异步逻辑时，一定要对不同时钟域之间的信号进行同步处理，不能直接使用相关信号，否则会产生亚稳态电路。

​	尽量不要直接将时钟信号与普通变量信号做逻辑操作，或对时钟信号进行电平信号的检测判断。

### 2.4. 综合

​	一般情况下，信号变量不要直接使用乘法 `*` 、除法 `\` 、求余 `%` 等操作。这些操作符被综合后，结构和时序往往不易控制。应该使用相关优化后的 IP 模块或工艺库中的集成模块。但是 `parameter` 类型的变量就可以使用此类操作符，因为在编译之初，编译器就会计算出常量运算的结果，不会消耗多余的硬件资源。组合逻辑的条件语句中条件补充完整，组合逻辑的 `always` 中敏感信号罗列完全，以避免不期望的 Latch 产生。

​	逻辑设计时要考虑代码能不能综合成实际电路，会综合成什么样的电路。

### 2.5. 例化

​	例化时，连接信号端的信号可以是 `reg` 型或 `wire` 型变量，连接输出端的信号一定是 `wire` 型变量。但是端口信号声明时，输入信号必须是 `wire` 型变量，输出信号可以是 `reg` 型或 `wire` 型变量。

## 3. 门的类型

​	门级建模，是使用基本的逻辑单元，进行更低级抽象层次上的设计。与行为级建模相比，门级建模更注重硬件的实现方法，即通过连接一些基本门电路去实现多种逻辑功能。

​	虽然，行为级建模最后也会被综合成基本的门级电路，但对于复杂的设计来说，行为级建模的效率远远高于门级建模。所以目前 Verilog 大多数用于描述数字设计的行为级层次（RTL），一般只注重设计实现的算法或流程，而不用特别关心具体的硬件实现方式。

​	另外一些设计，例如门控时钟，就需要使用基本门单元，来增加电路的可控性与可靠性。

### 3.1. 多输入门

​	多数入门只有单个输出，由单个或多个输入端。Verilog 内置多输入门有：`and` 、`nand` 、`or` 、`nor` 、`xor` 、`xnor` 。使用基本逻辑门单元去实现一些简单的逻辑功能时，使用模块例化的方式即可。门级单元第一个端口是输出，后面端口是输入，例化时，也可以不指定实例的名字。当输入端口超过 2 个时，只需将输入信号在端口列表中继续排列即可，Verilog 可自动识别。

```verilog
// basic gate instantiation
and 	a1			(OUTX,	IN1, IN2) ;
nand 	na1			(OUTX1, IN1, IN2) ;
or		or1			(OUTY, 	IN1, IN2) ;
nor 	nor1		(OUTY1, IN1, IN2) ;
// 3 input
xor xor1			(OUTZ, 	IN1, IN2, IN3) ;
// no instantiation name
xnor					(OUTZ1, IN1, IN2) ;
```

### 3.2. 多输出门

​	多出门只有单个输入，有单个或多输出端，又可称之为 `buffer` ，起缓冲、延时作用。

```verilog
// buffer
buf
// not
not
```

​	和多输入门类似，可以使用模块例化的方式对多输出门进行调用。门级单元第一个端口是输出，最后一个端口是输入。当输入端口超过 1 个时，需将输出信号在最后一个输入端口前排列。

```verilog
// buf
buf buf1		(OUTX2, IN1) ;
// 2 output
buf buf2		(OUTY2, OUTY3, IN2) ;
// no instantiation name
not					(OUTZ3, IN3) ; 
```

### 3.3. 三态门

​	Verilog 中，还提供了 4 个带有控制端的 buffer 门单元，成为三态门。只有当控制信号有效时，数据才能正常传递，否则输出为高阻抗状态 `z` 。

​	例化时，三态门第一个端口为输出端，第二个端口为数据输入端，第三个端口为控制输入端。例化时，信号排列顺序要一致，三态门不支持输出端口超过 1 个，但例化时可以不指定实例的名字。

```verilog
// tri
bufif1 buf1		(OUTX, IN1, CTRL1) ;
bufif0 buf2		(OUTZ, IN1, CTRL2) ;
bufif1 buf3		(OUTZ, IN1, CTRL3) ;
// no instantiation name
notif0 					(OUTX1, IN1, CTRL4) ;
```

### 3.4. 上下拉电阻

​	上拉是将不确定的信号通过一个电阻，钳制在一个高电平；下拉是将不确定的信号是通过一个电阻与地相连，固定在低电平。

​	模块端口的上拉或下拉电阻，具有限流、提高驱动能力、防静电等作用，可以有效保护电路；当信号方向为输入且没有输入信号（高阻态）时，上拉会将该信号的逻辑值置为 `1`， 下拉会将该信号的逻辑值置为 `0` 。

​	Verilog 提供了为信号设置上、下拉电阻的逻辑单元，多用于模块端口信号。此类门单元没有输入，只有输出，关键词如下。

```verilog
// set pull up
pullup
// set pull down
pulldown
```

​	例化调用时，只要填写需要设置上下拉电阻的信号即可，实例的名字也可以不指定。

## 4. 开关级建模

​	开关级建模是比门级建模更为低级抽象层次的射级。在极少数情况下，设计者可能会选择使用晶体管作为设计的底层模块。随着电路设计复杂度及相关先进工具的出现，以开关为基础的数字设计慢慢步入黄昏。目前，Verilog 仅仅提供了用逻辑值 0 、1 、x 、z 作为相关驱动强度的数字设计能力，因此，Verilog 中晶体管也仅被当作导通或截止的开关。

### 4.1. MOS 开关

​	MOS 开关有 2 种。

```verilog
// N type mos
nmos
// P type mos
pmos
// with high resistance N type mos
rnmos
// with high resistance P type mos
rpmos
```

​	MOS 管用来作为开关逻辑建模，数据从输入流入输出，可通过适当设置来开、关数据流。带有阻抗的 MOS 管，源极到漏极的阻抗较高，且在传递信号是会减小信号的强度。

​	例化时，MOS 管第一个端口为输出端，第二个端口为数据输入端，第三个端口为控制输入端。

```verilog
// tri
pmos pmos1		(OUTX, IN1, CTRL1) ;
// no instantiation name
nmos					(OUTX1, IN1, CTRL1) ;
```

### 4.2. CMOS 开关

​	CMOS 开关用关键字 `cmos` 和 `rcmos` （带有高阻抗）声明。CMOS 有一个数据输出，一个数据输入和 2 个控制输入。可以将 CMOS 开关看作是 NMOS 与 PMOS 开关的组合体。

​	例化时，CMOS 管第一个端口为输出端，第二个端口为数据输入端，第三个端口为 `Ncontrol` 控制输入端，第四个端口为 `Pcontrol` 控制输入端。

```verilog
// cmos
cmos c1		(OUTY, IN1, NCTRL, PCTRL) ;
// no instantiation name
cmos			(OUTY1, IN1, NCTRL, PCTRL) ;
```

​	既然 CMOS 可以看作是 NMOS 与 PMOS 开关的组合体，所以还可以用这两种 MOS 开关去搭建 CMOS 开关。

```verilog
// the same 2-way instancetiation of cmos
nmos n2		(OUTY, IN1, NCTRL) ;
pmos p2		(OUTY, IN1, PCTRL) ;
```

### 4.3. 双向开关

​	NMOS、PMOS、CMOS 开关门都是从漏极向源极导通，方向是单向的。Verilog 中还提供了双向导通的开关器件，数据可以双向流动，两边的信号都可以是驱动信号。

```verilog
tran tranif1 tranif0 rtran rtranif1 rtranif0
```

- `tran` ：为两个信号的直接缓存，`inout1` 或 `inout2` 均可以是驱动信号；
- `tranif1` ：仅当 `control` 信号为 1 时，开关两边的信号导通；当 `control` 为 0 时，两个信号断开，有驱动源的信号会和驱动源保持一致的信号值，没有驱动源的信号色泽呈现为高祖状态；
- `tranif0` ：同理。

​	因此，双向开关常用来进行总线或信号之间的隔离。例化时，双向开关前两个端口为数据端，第三个端口为 `control` 控制输入端。

```verilog
// tri
tranif0 tr0		(INOUT1, INOUT2, CONTROL) ;
// no instantition name
tranif1				(INOUT1, INOUT2, CONTROL) ;
```

### 4.4. 电源和地

​	晶体管级电路需要源极（Vdd，逻辑 1）与地级（Vss，逻辑 0），分别用关键字 `supply1` 和 `supply0` 来定义。

```verilog
supply1			VDD ；
supply0			GND ;
wire				siga = VDD ; // siga is connected to logic 1
wire				sigb = GND ; // sigb is connected to logic 0
```

## 5. 门延迟

​	实际门级电路都是有延迟的，Verilog 允许用户使用门延迟，来定义输入到其输出信号的传输延迟。

### 5.1. 延迟类型

#### 5.1.1. 上升延迟

​	在门的输入发生变化时，门的输出从 0 ，x ，z 变化为 1 所需要的转变时间，称为上升延迟。

#### 5.1.2.下降延迟

​	在门的输入发生变化时，门的输出从 1 ，x ，z 变化为 0 所需要的转变时间，成为下降延迟。

#### 5.1.3. 关断延迟

​	关断延迟是指门的输出从 0 ，1 ，x 变化为高阻态 z 所需要的转变时间。

#### 5.1.4. 延迟定义

​	门延迟可以在单元门例化时定义，定义格式如下。

```verilog
gate_type [delay]	[instance_name] (signal_list)
```

​	其中，`delay` 的个数可以为 0 个、1 个、2 个、或 3 个。

| 延迟类型 | 无延迟 | 1 个延迟 | 2 个延迟（d1，d2） | 3 个延迟（d1，d2，d3） |
| -------- | :----: | :------: | :----------------: | :--------------------: |
| 上升     |   0    |    d     |         d1         |           d1           |
| 下降     |   0    |    d     |         d2         |           d2           |
| 关断     |   0    |    d     |    min(d1, d2)     |           d3           |
| `to_x`   |   0    |    d     |    min(d1, d2)     |    min(d1, d2, d3)     |

### 5.2. 最小/典型/最大延迟

​	由于集成电路制造工艺的差异，实际电路中器件的延迟总会在一定的范围内波动。Verilog 中，用户不仅可以指定 3 中类型的门延迟，还可以对每种类型的门延迟指定其最小值、典型值和最大值。在编译或仿真阶段，来选择使用哪一种延迟值，为更切合实际的仿真提供了支持。

## 6. UDP 基础知识

​	门级建模中介绍的内置门单元，均属于 Verilog 自带的一整套标准原语，即通常所说的内置原语。此外，Verilog 还为用户提供了自己编写原语的能力，这种原语就是用户自定义原语（User Defined Primitive，UDP）。在UDP 中，不能调用其他 `module` 或 `primitive`，调用方式和门级原语完全相同。

### 6.1. UPD 定义

​	UDP 的定义不依赖于模块定义，因此可以出现在模块定义外，也可以单独在文件里定义。

```verilog
primitive UDP_name (
	output_name,
  list_of_input) ;
  
  output_declaration ;
  list_of_input_declaration ;
  [reg_declaration] ;
  [initial_statement] ;
  
  table
    list_of_table_entries ;
  endtable
endprimitive
```

### 6.2. UDP 说明

​	UDP 分为组合逻辑 UDP 和时序逻辑 UDP。

#### 6.2.1. 端口声明

- 端口声明部分和 `module` 类似，可以在端口列表声明时只列出端口信号，然后在 `primitive` 实体中说明其类型，也可以直接在端口列表声明时就指明其类型；
- 输入端口只能采用标量（即 1 位），允许有多个输入端口；
- 输出端口只允许有一个标量（即 1 位），且输出端口必须出现在端口列表的第一个位置是，绝对不允许有多个输出端口；
- 输出端口用 `output` 关键字说明，时许逻辑 UDP 需要保存状态，则其输出端口还需要声明为 `reg` 类型；
- UDP 不支持 `inout` 端口类型。

#### 6.2.2. 初始化

​	可以用 `initial` 语句对时序逻辑 UDP 的输出端口（`reg` 类型）进行初始化是，该语句是可选的。

#### 6.2.3. 状态表

- UDP 状态表是 UDP 中最重要的部分，用关键字 `table` 声明，它定义了如何根据输入状态和当前状态得到输出值，类似于逻辑真值表；
- 状态表的项可以为 0，1，或 x，UDP 不能处理 z 值，所以传递给 UDP 的 z 值会被当做 x 处理。

## 7. 组合逻辑 UDP

### 7.1. 与非门实例

​	组合逻辑 UDP 中，状态表规定了不同的输入组合和相对应的输出值，没有指定的任意组合输出值为 x 。

```verilog
primitive nand_my(
  output			out ;
  input 			a, b);
  
  table
  //a			b			:			out ;
    0			0			:			1 ;
    0 		1			:			1 ;
    1			0			:			1 ;
    1 		1			:			0 ;
  endtable
endprimitive
```

###  7.2. 状态表项

​	表示组合逻辑的状态表中的每一行的语法。

```verilog
<input1>		<input2>		...		<inputN> : <output> ;
```

- 状态表中的 `input` 信号顺序要与 UDP 端口列表的顺序一致；
- 输入和输出用冒号 `:` 隔开；
- 状态表的每一行以 `;` 结束；
- 能够产生确定输出值的所有输入项的组合都必须在状态表中列出，否则会输出 x 值。

### 7.3. 无关项

​	不影响输出结果的输入信号为无关项，可以用 `?` 表示。状态表中的 `?` 项将自动展开为 0，1 或 x 。

### 7.4. UDP 例化

​	UDP 调用格式与内置门级原语完全一致。

```verilog
nand_my			(G10, G30, G20) ;
```

## 8. 时序逻辑 UDP

​	时序逻辑 UDP 与组合逻辑 UDP 在定义形式和行为功能上均有不同。

- 时序逻辑 UDP 的输出端必须声明为 `reg` 型；

- 时序逻辑 UDP 是可以用 `initial` 语句初始化；

- 时序逻辑 UDP 状态表每行由 3 部分组成：输入部分、当前状态和输出状态，用 `:` 隔开；

  ```verilog
  <input_list> : <current_state> : <nect_state> ;
  ```

- `current_state` 就是输出寄存器的当前值的，`next_state` 就是输出寄存器的新值；`next_state` 由输入和 `current_state` 共同决定；

- 状态表的输入项可以是电平，也可以是跳变沿的形式。

### 8.1. 电平触发 UDP

​	电平触发 UDP 的输出是根据输入电平状态的改变而改变。

### 8.2. 边沿触发 UDP

​	边沿触发 UDP 的输出是根据输入跳边沿和输入电平状态的改变而改变。

```verilog
table
//RST			CP				D			:Q			:Q+
  // 时钟下降沿采样
  0				(10)			0			: ?			: 0 ;
  0 			(10)			1			: ?			: 1 ;
endtable
```

### 8.3. UDP 状态表符号缩写

| 缩写符 | 含义              | 说明                 |
| :----- | ----------------- | -------------------- |
| `?`    | 0 1 x             | 只能用于输入         |
| `b`    | 0 1               | 只能用于输入         |
| `-`    | 保持原值不变      | 只能用于输出         |
| `(ab)` | 信号由 a 变 b     | 用于输入端边沿的指示 |
| `r`    | (01)              | 信号上升沿           |
| `f`    | (10)              | 信号下降沿           |
| `p`    | (01) (0x) 或 (x1) | 可能是信号的上升沿   |
| `n`    | (10) (1x) 或 (x0) | 可能是信号的下降沿   |
| `*`    | (??)              | 信号任意边沿的变化   |

### 8.4. UDP 设计指导

​	针对数字设计时是选择使用 `module` 还是 `primitive` ，要从设计需求、复杂度等方面进行综合考虑。

- UDP 只能进行功能性建模，不能对电路时序和制造工艺（例如 CMOS，TTL 等）进行建模；使用 UDP 的主要目的是以类似于真值表的简介形式对数字设计进行建模，而 `module` 可以包含电路时序，并指定制造工艺；
- UDP 只能完成由一个输出端口的数字设计，当输出端口大于一个时，只能用 `module` ；
- UDP 是使用内存中的查找表实现的，当输入端口较多时，输入端口的组合将会呈指数增长，UDP 输入端口的数量也会受到仿真器的限制，因此输入端口较多时不宜使用 UDP ；
- 选择使用 UDP 以后，一定要尽可能的使用缩写符完整的描述 UDP 状态表；漏掉输入的组合情况，输出端可能会出现 x 的状态，造成设计错误。

## 9. 延迟模型

​	在实际电路设计时，必须检查设计中的延迟是否满足时序约束要求。可以用时序仿真的方法来检查时序（timing），即在仿真时向元件或路径中加入和实际相符的延迟信息，并进行相关计算来确定时序是否满足。

​	静态时序分析（Static Timing Analysis，STA），也是一种时序验证的技术。它不关心逻辑功能的正确与否，只对设计中的时序进行计算分析，来确定电路中是否存在违反（violation）时序约束的设计。STA 分析速度快，能够快速定位问题，但会忽略一些异步的问题。

​	STA + 时序仿真是一种相对完善且相对安全的时序验证方法。

### 9.1. 分布延迟

​	分布延迟需要给电路每个独立的元件进行延迟定义，不同的路径有不同的延时。

```verilog
module and4(
	output			out,
  input				a, b, c, d);
  
  wire				an1 ,an2 ;
  and #1			(an1, a, b) ;
  and #2 			(an2, c, d) ;
  and #1.5		(out, an1 ,an2) ;
endmodule
```

​	也可以使用连续赋值语句 `assign` 说明分布延迟。

```verilog
module and4(
   output       out,
   input        a, b, c, d);

   wire         an1, an2 ;
   assign #1    an1 = a & b ;
   assign #2    an2 = c & d ;
   assign #1.5  out = an1 & an2 ;
endmodule
```

### 9.2. 集总延迟

​	集总延迟是将全部路径累计的延时集中到最后一个门单元上。到最后一个门单元上的延迟会因路径的不同而不同，此时取最大延时作为最后一个门单元的延时。

```verilog
module and4(
	output			out,
  input				a, b, c, d);
  
  wire				an1 ,an2 ;
  and 				(an1, a, b) ;
  and 	 			(an2, c, d) ;
  and #3.5		(out, an1 ,an2) ;
endmodule
```

### 9.3. 路径延迟

​	路径延迟是对每个输入引脚到每个输出引脚的所有路径指定延迟时间。路径延迟模型需要用关键字 `specify` 定义。

```verilog
specify
  (a => out) = 2.5 ;
  (b => out) = 2.5 ;
  (c => out) = 3.5 ;
  (d => out) = 3.5 ;
endspecify
```

### 9.4. 延迟模型比较

- 分布延迟：分布延迟将延迟时间分散在了每一个门单元上，但仍然不能描述基本单元中不同引脚上延时的差异，当设计规模变大时，结构将变得复杂；
- 集总延迟：该方式模型简单，适用于小规模的电路，但是不同描述输入端到输出端不同路径的延迟；
- 路径延迟：指定了引脚到引脚的延迟，延迟信息比较齐全，虽然信息比较多，但对于大规模电路也更容易实现；因为设计者无需关心模块内部的实现逻辑，只需要了解输入到输出引脚的延迟即可；即便模块内部逻辑有所改变，路径延迟的说明也可以保持不变。

## 10. specify 块语句

### 10.1. 并行连接

​	每条路径都有一个源引脚和目的引脚，将这些路径的延迟一次用 `specify` 语句描述出来，称为并行链接。

```verilog
(<source_io) => <destination_io>) = <delay_value> ;
```

​	可以用 `specparam` 在 `specify` 块中定义延迟数值常量，然后赋值给路径延迟。`specparam` 定义的常量只能在 `specify` 块内部使用。

```verilog
specparam name = value ;
```

### 10.2. 全连接

​	在全连接中，源引脚中的每一位于目标引脚的每一位相连接。源引脚和目标引脚的连接是组合遍历的，且不要求位宽对应。

```verilog
(<multiple_source_io> *> <multiple_destination_io>) = <delay_value> ; 
```

### 10.3. 边沿敏感路径

​	边沿敏感路径用于输入到输出延迟的时序建模，并使用边缘标识符指明触发条件。如果没有指明的话，任何变化都会触发源引脚到目的引脚的延迟值的变化。

```verilog
// 在 clk 上升沿触发，从 clk 上升沿至 out 上升沿，延迟为 1；从 clk 上升沿至 out 下降沿，延迟为 2
// 从 in 到 out 的数据路径是同向的，即 out = in
(posedge clk => (out +: in)) = (1, 2) ;
```

### 10.4. 条件路径

​	Verilog 也允许模型中根据信号值的不同，有条件的给路径延迟进行不同的赋值。条件中的操作数可以是标量可以是向量，条件表达式也可以包含任意操作符。

```verilog
specify
  if (a)			(a => out) = 2.5 ;
  if (~a)			(a => out) = 1.5 ;
  
  if (b & c)			(b => out) = 2.5 ;
  if (!(b & c))		(b => out) = 1.5 ;
  
  if ({c, d} == 2'b01)
    					(c, d *> out) = 3.5 ;
  ifnone 			(c, d *> out) = 3 ;
endspecify
```

**注意**：

- 应当只使用 `if` 语句将条件路径中所有的输入状态都完整的声明；
- 没有声明的路径会使用分布延迟，分布延迟也没有声明的话，将使用零延迟；
- 如果路径延迟和分布延迟同时声明，将选择最大的延迟作为路径延迟；
- `specify` 中的 `if` 语句不能使用 `else` 结构，可以使用 `ifnone` 描述条件缺省时的路径延迟。

###  10.5. 门延迟路径

​	门延迟（上升延迟、下降延迟、关断延迟）的数值也可以通过路径延迟的方法来描述。可以定义的延迟路径个数为 1 个，2 个，3 个， 6 个，12 个，其他数量的延迟值都是错误的。

```verilog
// 1 param: rise, fall and shut use the same parameter
specify
  specparam t_delay = 1.5 ;
  (clk => q) = t_delay ;
endspecify

// 2 param: rise	(0 -> 1, z -> 1, 0 -> z)
//					fall	(1 -> 0, z -> 0, 1 -> z)
specify
  specparam t_rise = 1.5, t_fall = 2 ;
  (clk => q) = (t_rise, t_fall) ;
endspecify

// 3 param: rise	(0 -> 1, z -> 1)
//					fall	(1 -> 0, z -> 0)
specify
  specparam t_rise = 1.5, t_fall = 2.5, t_turnoff = 1.8 ;
  (clk => q) = (t_rise, t_fall, t_turnoff) ;
endspecify

// 6 param: 0 -> 1, 1 -> 0, 0 -> z, z -> 1, 1 -> z, z -> 0 respectively
specify
  specparam t_01 = 1.5, t_10 = 2, 	t_0z = 1.8 ;
  specparam t_z1 = 2,   t_1z = 2.2, t_z0 = 2.1 ;
  (clk => q) = (t_01, t_10, t_0z, t_z1, t_1z, t_z0) ;
endspecify

// 12 param: 0 -> 1, 1 -> 0, 0 -> z, z -> 1, 1 -> z, z -> 0
//					 0 -> x, x -> 1, 1 -> x, x -> 0, x -> z, z -> x repectively
specify
  specparam t_01 = 1.5, t_10 = 2, 	t_0z = 1.8 ;
  specparam t_z1 = 2,   t_1z = 2.2, t_z0 = 2.1 ;
  specparam t_0x = 1.1, t_x1 = 1.2, t_1x = 2.1 ;
  specparam t_x0 = 2,   t_xz = 2,   t_zx = 2.1 ;
  
  (clk => q) = (t_01, t_10, t_0z, t_z1, t_1z, t_z0, 
                t_0x, t_x1, t_1x, t_x0, t_xz, t_zx) ;
endspecify
```

​	门延迟路径模型中，也可以指定最大值、最小值和典型值。

```verilog
// rise, fall and turnoff's delay: min: typicla: max
specify
  specparam t_rise = 1:1.5:1.8 			;
  specparam t_fall = 1:1.8:2	 			;
  specparam t_turnoff = 1.1:1.2:1.3 ;
  (clk => q) = (t_rise, t_fall, t_turnoff) ;
endspecify
```

### 10.6. x 传输延迟

​	如果没有指定 x 转换时间的延迟（门路径延迟中没有给出 12 个延迟参数），则规定：

- 从 x 转换为已知状态的延迟时间为，可能需要的最大延迟时间；
- 从已知状态转换为 x 的延迟时间为，可能需要的最小延迟时间。

## 11. 建立时间和保持时间

### 11.1. 基本概念

​	建立时间是时钟触发事件来临之前，数据需要保持稳定的最小时间，以便数据能够被时钟正确的采样；保持时间是时钟触发事件来临之后，数据需要保持稳定的最小时间，以便数据能够被电路准确的传输。

### 11.2. 约束条件

#### 11.2.1. 建立时间约束条件

​	时钟到来之前，数据需要提前准备好，才能被时钟正确采样，要求数据路径（data path）比时钟路径（clock path）更快，即数据到达时间（data arrival time）小于数据要求时间（data required time）。

$$
T_{cq} + T_{comb} + T_{su} \le T_{clk} + T_{skew}
$$

- $T_{cq}$ ：寄存器 `clock` 端到 `Q` 端的延迟；
- $T_{comb}$ ：data path 中组合逻辑延迟；
- $T_{su}$ ：建立时间；
- $T_{clk}$ ：时钟周期；
- $T_{skew}$ ：时钟偏移。

​	理论上，电路能够承载的最小时钟周期为 $T_{cq} + T_{comb} + T_{su} - T_{skew}$ 。

#### 11.2.2. 保持时间约束条件

​	时钟到来之后，数据还要稳定一段时间，这就要求前一级的数据延迟（data delay time）不要大于触发器的保持时间，以免数据被冲刷掉。
$$
T_{cq} + T_{comb} \ge Thd + T_{skew}
$$

- $T_{cq}$ ：寄存器 clock 端到 Q 端的延迟；
- $T_{comb}$ ：data path 中的组合逻辑延迟；
- $Thd$ ：保持时间；
- $T_{skew}$ ：时钟偏移。

## 12. 时序检查

​	指定路径延迟，目的是让仿真的时序更加接近实际数字电路的时序。利用时序约束对数字设计进行时序仿真，检查设计是否存违反（violation）时序约束的地方，并加以修改。Verilog 提供了一些系统任务，用于时序检查，这些任务只能在 `specify` 块中调用。

### 12.1. $setup \$hold

​	系统任务 `$setup` 用来检查设计中元件的建立时间约束条件，`$hold` 用来检查保持时间约束条件。

```verilog
$setup(data_event, ref_event, setup_limit);
```

- `data_event` ：被检查的信号，判断它是否违反约定；
- `ref_event` ：用于检查的参考信号，一般为时钟信号的跳变沿；
- `setup_limit` ：设置的最小建立时间。

**注意**：如果 $T(ref\_event - data\_event) < setup\_limit$ ，则会打印存在 `violation` 的报告。

```verilog
$hold(ref_event, data_event, hold_limit);
```

- `data_event` ：被检查的信号，判断它是否违反约定；
- `ref_event` ：用于检查的参考信号，一般为时钟信号的跳变沿；
- `setup_limit` ：设置的最小保持时间。

**注意**：如果 $T(data\_event - ref\_event) < hold\_limit$ ，则会打印存在 `violation` 的报告。

​	Verilog 还提供了同时检查建立时间和保持时间的系统任务 `$setuphold (ref_event, data_event, setup_limit, hold_limit);`

### 12.2. $recovery \$removal

​	建立时间和保持时间的概念都是出现在同步电路的设计中。对于异步复位的触发器来说，异步复位信号也需要满足 recovery time（恢复时间）和 removal time（去除时间），才能有效的复位和释放复位，防止出现亚稳态。

​	释放复位时，复位信号在时钟有效沿来临之前就需要提前一段时间恢复到非复位状态，这段时间为 recovery time 。类似于同步时钟下的触发器的 setup time 。

​	复位时，复位信号在时钟有效沿来临之后，还需要在一段时间内保持不变，这段时间为 removal time 。类似于同步时钟下触发器的 hold time 。

​	系统任务 `$recovery$` 与 `$removal$` 分别用于 recovery 和 removal time 的检查。

```verilog
$recovery (ref_event, data_event, recovery_limit) ;
```

- `ref_event` ：用于检查的参考信号，一般为清零或复位信号跳变沿；
- `data_event` ：被检查的信号，一般为时钟信号跳变沿；
- `recovery_limit` ：设置的最小 recovery time 。

**注意**：当 `ref_event(reset) < data_event(clock)` 且 `T(data_event - ref_event) < recovery_limit` 时，即复位信号在时钟信号到来之前，如果不满足 recovery time ，则报告中会打印 violation 。

```verilog
$removal (ref_event, data_event, removal_limit) ;
```

- `ref_event` ：用于检查的参考信号，一般为清零或复位信号跳变沿；
- `data_event` ：被检查的信号，一般为时钟信号跳变沿；
- `removal_limit` ：设置的最小 removal time 。

**注意**：当 `ref_event(reset) < data_event(clock)` 且 `T(data_event - ref_event) > removal_limit` 时，即复位信号在时钟信号到来之前，如果不满足 removal time ，则报告中会打印 violation 。

​	Verilog 还提供了同时检查 removal 和 recovery 的系统任务。

```verilog
$recrem (ref_event, data_event, recovery_limit, removal_limit) ;
```

### 12.3. $width \$period

​	有些数字设计，例如 flash 存储器，还需要对脉冲宽度或周期进行检查，为此 Verilog 分别提供了系统任务 `$width` 和 `$period` 。

```verilog
$width(ref_event, time_limit) ;
```

- `ref_event` ：边沿触发事件；
- `time_limit` ：脉冲的最小宽度。

​	如果两次相反跳变沿之间的时间小于 time_limit ，则会报告 violation 。

```verilog
$period(ref_event, time_limit) ;
```

​	如果两次同样跳变沿之间的时间小于 time_limit ，则会报告 violation 。

## 13. 延迟反标注

​	延迟反标注是设计者根据单元库工艺、门级网表、版图中的电容电阻等信息，借助数字设计工具将延迟信息标注到门级网表中的过程。利用延迟反标注后的网表，就可以进行精确的时序仿真，使仿真更接近实际工作的数字电路。

### 13.1. 过程

1. 利用硬件描述语言完成 RTL 层级的描述，进行功能仿真；
2. 对时钟、复位、输出端口等信号进行一定的时序约束，并用于逻辑综合；
3. 去除综合出的门级网表所包含的延迟信息，并初步验证 setup 等时序是否满足要求；
4. 对门级网表进行布局布线，转换为版图级网表，并根据元器件几何形状和制造工艺等计算版图延迟值；
5. 将布局布线后版图中的延迟信息反标注至版图级网表，并验证时序是否满足；
6. 验证通过，则可以进行下载或实现，如果有 violation ，首先需要检查时序约束设置，再重新布局布线验证，如果还是无法消除，则需要回到设计初始，优化 RTL 的描述。

### 13.2. SDF 文件

​	SDF（Standard Delay Format），标准延时格式文件，常用延迟反标注。该文件包含了仿真用到的所有 IOPATH、INTERCONNECTION、TIMING CHECK 等延迟时间和时序约束的参数。

#### 13.2.1. 文件格式

​	SDF 文件用关键字 DELAYFILE 声明，并包含 DESIGN、DATE 等关键字信息。延迟时间和时序约束参数均在 CELL 中说明。SDF 文件就是有文件声明信息和很多个不同的 CELL 组成的。

```verilog
(DELAYFILE
  (DESIGN "top")
  (DATE "...")
...
  (TIMESCALE 1ns)
  (CELL
  ...
  )
  (CELL
  ...
  )
...
)
```

#### 13.2.2. 延迟类型

​	SDF 文件中的延迟类型包括 cell delay 和 wire delay 。cell delay 指逻辑门单元器件内部的延迟，wire delay 是指器件之间通过 wire 互联的延迟。

##### cell delay

​	用于定义输入、输出端口之间的上升延迟和下降延迟。

```verilog
(CELL
  (CELLTYPE "module_name")
  (INSTANCE instance_name)
  (DELAY
    (ABSOLUTE
      (IOPATH A Z (1.5::1.8) (1.3::1.7))
      (IOPATH B Z (1.5::1.8) (1.3::1.7))
    )
  )
)
```

##### wire delay

​	用于定义不同模块之间的走线延迟。

```verilog
(CELL
  (CELLTYPE "module_name")
  (INSTANCE instance_name)			// can be omitted if here is top module
  (DELAY
    (ABSOLUTE
      (INTERCONNECT u_and.Z u_dt.D (0.500::0.751) (0.400::0.551))
      // (INTERCONNECT u_and/Z u_dt/D (0.500::0.751) (0.400::0.551))
      // Hierarchical access symbol: some support / , other suport .
    )
  )
)
```

#### 13.2.3. 条件延迟及时序检查

​	CELL 中还可以用关键字 COND 指定条件延迟。同时，也可以再 CELL 内做时序检查。

```verilog
(CELL
  (CELLTYPE "d_gate")
  (INSTANCE u_dt)
  (DELAY
    (ABSOLUTE
    // when D is 1, positive delay is  1.3, negative delay is 1.5
    (COND D==1'b1 (IOPATH CP Q (1.3::2.3) (1.5::2.2)))
    // when D is 0, positive delay is  1.2, negative delay is 1.4
    // Here is only 
    // This is just to illustrate COND usage，D=1时下降延迟参数不可能用到
    // the negative delay for D is 1 is impossible
    (COND D==1'b0 (IOPATH CP Q (1.2::2.1) (1.4::2.0)))
    )
  )
  //setup check, when D-CP time is less than 0.8 or 1, print violation
  (TIMINGCHECK
  (SETUP D (posedge CP) (0.8::1)) 
  )
)
```

### 13.3. 使用方法

​	Verilog 提供了系统函数 `$sdf_annotate` 去调用SDF 文件完成延迟反标注的过程。

```verilog
$sdf_annotate ('sdf_file'[, module_instance] [, 'sdf_configfile'] [, 'sdf_logfile'] [, 'mtm_spec'] [, 'scale_factors'] [, 'scale_type']) ;
```

- `sdf_file` ：SDF 文件名字，包含路径信息；
- `module_instance` ：例化的设计模块名字，一般为 testbench 中所例化的数字设计模块名称，注意和 SDF 文件内容中的声明保持层次的一致；
- `log_file` ：编译时关于 SDF 的日志；
- `mtm_spec` ：指定使用的延迟类型，选项包括 `MAXIMUM` 、`MINIMUM` 、`TYPICAL` ，分别表示使用 SDF 文件中标注的最大值、最小值或典型值。

## 14. 同步与异步

#### 14.1. 同步时钟

​	数字设计中，一般认为，频率相同或频率比为整数倍、且相位相同或相位差固定的两个时钟为同步时钟。或者理解为，时钟同源且频率比为整数倍的两个时钟为同步时钟。

#### 14.1.1. 同源同频同相位

​	此类时钟频率和相同均相同，是同步的。时钟间数据传输只要满足正常的建立时间和保持时间即可，不需要特殊的同步设计。

#### 14.1.2. 同源同频不同相位

​	两个时钟同频但不同相位时，只要相位差保持固定，也可以认为是同步的。只要控制两个时钟间传输的数据延迟在合理的范围内，就不会导致时序问题。而且，固定的时钟延迟也可以在版图级网表中修复。

​	固定的相位差可以理解为同源时钟下两个时钟因路径不同而导致的偏移。

#### 14.1.3. 同源不同频但存在整数倍分频

​	此类情况下，一个时钟往往是另一个时钟的分频，即便存在相位差也是固定的。

​	当单 bit 信号从慢时钟域传递到快时钟域时，因为同源，只要满足建立时间和保持时间，快时钟域总会采集到从慢时钟域传递来的信号。

​	当单 bit 信号从快时钟域传递到慢时钟域时，只要慢时钟能安全采集到从快时钟域传递来的信号，就不存在异步问题。

​	但是如果快时钟域信号过窄，慢时钟域可能会漏掉该信号，此时就需要对快时钟域的窄脉冲信号进行展宽。当两个时钟频率比相对较小时， 可以在快时钟域采用对信号延迟的方法进行展宽；当两个时钟频率比相对较大时，可以在快时钟域采用计数的方法来延长单 bit 信号有效的时间。

### 14.2. 异步时钟

​	工作在异步时钟下的两个模块进行数据交互时，由于时钟相位关系不可控制，很容易导致建立时间和保持时间 violation 。

#### 14.2.1. 不同源

​	由两个不同的时钟源产生的两个时钟是异步的，这是最常见的异步时钟。即便两个时钟频率相同，但是也不能保证每次上电后两者的相位或相位差是相同的，所以信号间的传输与时钟关系也是不确定的。

#### 14.2.2. 同源但频率比不是整数倍

​	此时两个时钟间相位差也可能会有多个，他们之间也会出现多个相位差，时序也难以控制，一般情况也需要当异步时钟处理。

#### 14.2.3. 同源且频率比为整数倍但不满足时序要求

​	信号在快时钟域反转速率过快，慢时钟域可能不会安全的采集到从快时钟域传来的信号，这也可以认为是异步问题。一般来说，慢时钟域时序约束较为宽松，快时钟域较为严格。

## 15. 跨时钟域传输

### 15.1. 慢到快

​	理论上将，快时钟域的信号总会采集到慢时钟域传输来的信号，如果存在异步可能会导致采用数据出错，所以需要进行同步处理。此类同步处理相对简单，一般采用延迟打拍法，或延迟采样法。

#### 15.1.1. 延迟打拍法

​	最常用的同步方法是双级触发器缓存发，俗成延迟打拍法。异步信号从一个时钟域进入另一个时钟域之前，将该信号用两级触发器连续缓存两次，可有效降低因为时序不满足而导致的亚稳态问题。

#### 15.1.2. 延迟采样法

​	此方法主要针对多位宽的数据传输。该方法的基本思想是保证信号被安全采集的时刻，而不用同步多位宽的数据信号，可节省部分硬件资源。

### 15.2. 快到慢

​	信号从快时钟域传输到慢时钟域来时，需要根据信号的特点来进行同步处理。对于单 bit 信号，一般可按电平信号和脉冲信号来区分。

#### 15.2.1. 电平信号同步

​	同步逻辑设计中，电平信号是指长时间保持不变的信号。保持不变的时间限定是相对于慢时钟而言的。只要快始终的信号保持高电平或低电平的时间足够长，以至于能被慢时钟在满足时序约束的条件下采集到，就可以认为该信号为电平信号。

​	既然电平信号能够被安全的采集到，所以从快时钟域到慢时钟域的电平信号也采用延迟打拍的方法做同步。

#### 15.2.2. 脉冲信号同步

​	同步设计逻辑中，脉冲信号是指从快时钟域输出的有效宽度小于慢时钟周期的信号。如果慢时钟域直接去采集这种窄脉冲信号，有可能会漏掉。  

​	假如这种脉冲信号脉宽都是一致的，在知道两个时钟频率比的情况下，可以采用快时钟域脉宽扩展和慢时钟域延迟打拍的方法进行同步。

​	如果有时窄脉冲信号又表现出电平信号的特点，即有时信号的有效宽度大于慢时钟周期而能被慢时钟采集到，那么对于此类信号再进行脉冲扩展显然是不经济的。此时可通过握手传输的方法进行同步。

##### 握手传输

- 快时钟域对脉冲信号进行检测，检测为高电平时输出高电平信号 `pulse_fast_r` ，或者快时钟域输出高电平信号时，不要急于将信号拉低，先保持输出信号为高电平状态；
- 慢时钟域对快时钟域的信号 `pulse_fast_r` 进行延迟打拍采样，因为此时的脉冲信号被快时钟域保持拉高状态，延迟打拍肯定会采集到信号；
- 慢时钟域确认采样的到高电平信号 `pulse_fast2s_r` 后，再反馈给快时钟域；
- 快时钟域对反馈信号 `pulse_fast2s_r` 进行延迟打拍采样；如果检测到反馈信号为高电平，证明慢时钟域已经接收到有效的高电平信号；如果此时快时钟域自身逻辑不再要求脉冲信号为高电平状态，拉低快时钟域的脉冲信号即可。

#### 15.2.3. 多位宽数据同步

​	当多位宽数据进行同步时，如果该数据各 bit 位都可以看作电平信号，即相对一段时间内各 bit 位数据均可以保持不变以至于能被慢时钟采集到，可以消耗一些触发器资源对多位宽数据进行简单的延迟打拍同步。

​	但如果数据变化速率过快，就不能再使用延迟打拍采样的方法，因此此时数据各 bit 位不再是电平信号，变化时间也参差不齐，用异步时钟进行打拍采样，可能会采集到因路径延迟不同而导致的错误数据。解决此类异步问题的常用方法是采用异步 FIFO（First In Fisrt Out）。

## 16. FIFO 设计

​	FIFO（First In First Out）是异步数据传输时经常使用的存储器。该存储器的特点时数据先进先出。其实，多位宽数据的异步传输问题，无论是从快始终到慢时钟域，还是从慢时钟到快时钟域，都可以使用 FIFO 处理。

### 16.1. FIFO 原理

#### 16.1.1. 工作流程

​	复位之后，在写时钟和状态信号的控制下，数据写入 FIFO 中，RAM 的写地址从 0 开始，每写一次数据写地址指针加一，只向下一个存储单元。当 FIFO 写满后，数据将不能再写入，否则数据会因覆盖而丢失。

​	FIFO 数据为非空、或满状态时，在读时钟和状态信号的控制下，可以将数据从 FIFO 中读出。RAM 的读地址从 0 开始，每读一次数据读地址指针加一，指向下一个存储单元。当 FIFO 读空后，就不能再读数据，否则读出的数据将是错误的。

​	FIFO 的存储结构为双口 RAM ，所以允许读写同时进行。典型异步 FIFO 结构图如下所示。端口及内部信号将在代码编写时进行说明。

#### 16.1.2. 读写时刻

​	关于写时刻，只要 FIFO 中数据为非满状态，就可以进行写操作；如果 FIFO 为满状态，则禁止再写数据。

​	关于读时刻，只要 FIFO 中数据为非空状态，就可以进行读操作；如果 FIFO 为空状态，则禁止再读数据。

​	不管怎样，一段正常读写 FIFO 的时间段，如果读写同时进行，则要求写 FIFO 速率不能大于读速率。

#### 16.1.3. 读空时刻

​	开始复位时，FIFO 没有数据，空状态信号有效。当 FIFO 中被写入数据后，空状态信号拉低无效。当读数据地址追赶上写地址，即读写地址都相等时，FIFO 为空状态。

​	因为是异步 FIFO ，所以读写地址进行比较时，需要同步打拍逻辑，就需要耗费一定的时间。所以空状态的指示信号不是实时的，会有一定的延时。如果再这段延迟时间内又有新的数据写入 FIFO ，就会出现空状态指示信号有效，但是 FIFO 中其实存在数据。

​	严格来讲，该空状态指示是错误的，但是产生空状态的意义在于防止读操作对空状态的 FIFO 进行数据读取。产生空状态信号时，实际 FIFO 中有数据，相当于提前判断了空状态信号，此时不再进行读 FIFO 数据操作也是安全的。所以，该设计从应用上来说是没有问题的。

#### 16.1.4. 写满状态

​	开始复位时，FIFO 没有数据，满信号是无效的。当 FIFO 中被写入数据后，此时读操作不进行或读速率相对较慢，只要写数据地址超过读数据地址一个 FIFO 深度时，就会产生满状态信号。此时写地址和读地址也是相等的，但是意义是不一样的。

​	同理，由于异步延迟逻辑的存在，满状态信号也不是实时的。但是也相当于提前判断了满状态信号，此时不再进行写 FIFO 操作也不会影响应用的正确性。

### 16.2. FIFO 设计

#### 16.2.1. 设计要求

​	为设计应用于各种场景的 FIFO ，这里对设计提出如下要求：

- FIFO 深度、宽度参数化，输出空、满状态信号，并输出一个可配置的满状态信号；当 FIFO 内部数据达到设置的参数数量时，拉高该信号；
- 输入数据和输出数据位宽可以不一致，但要保证写数据、写地址位宽与读数据、读地址位宽的一致性；
- FIFO 是异步的，即读写控制信号来自不同的时钟域；输出空、满状态信号之前，读写地址信号要用格雷码做同步处理，通过减少多位宽信号的翻转来减少打拍法同步时数据的传输错误。

## 17. 复位简介

​	为确保系统上电后有一个明确、稳定的初始状态，或系统运行状态紊乱是可以恢复到正常的初始状态，数字系统设计中一定要有复位电路模块。复位电路异常可能会导致整个系统的功能一场，所以在一定程度上，复位电路的重要性也不亚于时钟电路。

### 17.1. 同步复位

​	同步复位是指复位信号在时钟有效边沿到来时有效。如果没有时钟，无论复位信号怎样变化，电路也不执行复位操作。

**优点**：信号间是同步的，能滤除复位信号中的毛刺，由此与时序分析。

**缺点**：大多数触发器单元是没有同步复位端的，采用同步复位会消耗部分逻辑资源。且复位信号的宽度必须大于一个时钟周期，否则可能会漏掉复位信号。

### 17.2. 异步复位

​	异步复位是指无论时钟到来与否，只要复位信号有效，电路就会指型复位操作。

**优点**：大多数触发器单元有异步复位端，不会占用额外的逻辑资源。且复位信号不经过处理直接引用，设计相对简单，信号识别快速方便。

**缺点**：复位信号与时钟信号无确定的时序关系，异步复位很容易引起时序上 removal 和 recovery 的不满足。且异步复位容易受到毛刺的干扰，产生以外的复位操作。

### 17.3. 异步复位同步释放

​	综合设计与资源等方面考虑，一般数字系统设计时都会使用异步复位。为消除异步复位的缺陷，复位电路往往会采用异步复位，同步释放的设计方法。即复位信号到来时不受时钟信号的同步，复位信号释放时需要进行时钟信号的同步。

​	需要说明的是，复位电路会消耗更多的硬件逻辑和面积资源，增加系统设计的复杂性。不带复位端的触发器也具有相对较高的性能。所以在一些初始值不影响逻辑正确性的数字设计中，可以考虑去掉复位以达到最佳性能。

## 18. 时钟简介

​	几乎稍微复杂的数字设计都离不开时钟。时钟也是所有时序逻辑建立的基础。

### 18.1. 时钟源

​	根据时钟源在数字设计模块中位置的不同，可以将时钟源分为外部时钟和内部时钟。

#### 18.1.1. 外部时钟源

​	RC/LC 振荡电路，无源/有源晶体振荡器等。

#### 18.1.2. 内部时钟源

​	锁相环（Phase Locked Loop，PLL），利用外部输入的参考信号控制环路内部振荡信号的频率和相位，实现输出信号频率对输入信号频率的自动追踪，通过反馈通路将信号倍频到一个较高的固定频率。

​	一般晶振由于工艺和成本原因，做不到很高频率，利用 PLL 电路可以实现稳定且高频的时钟。PLL 集成到设计模块的内部，可以保证数字电路具有较好的延迟和稳定性。

### 18.2. 时钟特性

​	仿真时，所有同步的时钟都是理想的，时钟的翻转是在瞬间完成的，模块之间的时钟沿都是对齐的，没有延迟，没有抖动。实际电路中，时钟在传输、翻转时都会有延迟。

#### 18.2.1. 时钟偏移（Skew）

​	由于线网的延迟，时钟信号在到达触发器端口时，不能保证不同触发器端口的时钟是对齐的，即不同触发器端口的时钟相位存在差异。这种差异称为时钟偏移。

​	一般时钟偏移与时钟频率没有直接的关系，与走线长度、负载电容、负载数量等因素有关。

#### 18.2.2. 时钟抖动（Jitter）

​	相对于理想时钟沿，实际时钟中存在不随时间积累的、时而超前、时而滞后的偏移称为时钟抖动。可以用抖动频率和抖动幅度对时钟抖动进行定量描述。数字设计中，时钟抖动都是用时间来描述。

​	时钟抖动可分为随机抖动和固定抖动。随机抖动来源于热噪声、半导体工艺等；固定抖动来源于开关电源、电磁干扰或其他不合理的布局布线等。在综合工具 Design Compiler 中，时钟的偏移和抖动统一用不确定度 uncertainty 来统一表示。

#### 18.2.3. 转换时间（Transition）

​	时钟从高电平跳变到低电平，或者从低电平跳变到高电平时，并不是直上直下的，而是斜坡式需要一个过渡时间。这个时间称为时钟的转换时间。

​	转换时间大小与单元库工艺、电容负载有关。

#### 18.2.4. 时钟延时（Lantency）

​	时钟从时钟源出发到达触发器端口的延迟时间，称为延迟时间。时钟延迟包括时钟源延迟（Source Lantency）和时钟网络延迟（Netword Lantency）。

​	时钟源延时，是时钟信号从实际时钟远点到设计模块时钟定义点的传输时间；时钟网络延时，是从设计模块时钟定义点到模块内触发器时钟端的传输时间，传输路径上可能经过缓冲器（buffer）。

​	时钟源延时（Source Lantency）是设计模块内所有触发器共有的延时，所以不会影响时钟偏移（Skew）。

### 18.3. 时钟树

​	数字设计时，各个模块应当使用同步时钟电路，同步电路中被相同时钟信号驱动的触发器共同组成一个时钟域。实际中，因为各种延迟的存在，这种无延迟的时钟特性难以实现。而且时钟信号的驱动能力有限，难以独立的为一个包含较多触发器的时钟域提供有效扇出。为解决时钟延迟与驱动的问题就需要采用时钟树系统对时钟信号进行管理，来确保良好的时序和驱动能力。

​	时钟树，是一个有多个缓冲单元（buffer）平衡搭建的网状结构。一般由一个时钟源点，经一级一级的缓冲单元搭建而成。时钟树并不是为了减少时钟信号到达各个触发器的时间，而是减少到达各个触发器之间的时间差异。

## 19. 时钟分频

### 19.1. 偶数分频

​	采用触发器反向输出端反馈至输入端的方式，可构成简单的 2 分频电路，以此为基础进行级联，可构成 4 分频，8 分频电路。

### 19.2. 奇数分频

​	奇数分频如果不要求占空比为 50% ，可按照偶数分频的方法进行分频。即计数器对分频系数 N 进行循环，然后根据计数值选择一定的占空比输出分频时钟。

​	如果奇数分频输出时钟的高低电平只差一个 cycle ，则可以利用源时钟双边沿特性，获取两个输出时钟，并采用与操作或或操作的方式将分频时钟占空比调整到 50% 。

### 19.3. 半整数分频

​	利用时钟的双边沿逻辑，可以对时钟进行半整数的分频。但是无论怎么调整，半整数分频的占空比不可能是 50% 。

### 19.4. 小数分频

#### 19.4.1. 基本原理

​	不规整的小数分频不能做到分频后的每个时钟周期都是源时钟周期的小数分频倍，更不能做到分频后的时钟占空比均为 50% ，因为 Verilog 不能对时钟进行小数计数。小数分频可以基于可变分频和多次平均的方法实现。

​	例如，进行 7.6 倍分频，则保证源时钟 76 个周期的时间等于分频时钟的 10 个周期的时间即可。此时需要在 76 个源时钟周期内进行 6 次 8 分频，4 次 7 分频。

#### 19.4.2. 平均原理

​	为了防止时钟频率不均匀，相位抖动大，一般会采用平均插入的方法进行小数分频操作。

## 20. 时钟切换

​	随着各种应用场景的限制，芯片在运行时往往需要在不同的应用下切换不同的时钟源。两个时钟源有可能是同源且同步的，也有可能是不相关的。直接使用选择逻辑进行时钟切换大概率会导致分频时钟信号出现毛刺现象，所以时钟切换逻辑也需要进行特殊的处理。

### 20.1. 时钟切换方案

​	在两个电平相反的时候切换时钟，肯定有毛刺；电平相同的时候，即使不产生毛刺，时钟切换后的第一个时钟的周期或占空比也不是理想的。所以，为避免毛刺的产生，需要在两个时钟都为低电平的时候进行电平转换。

​	考虑到选择信号有可能是异步信号，需要在时钟选择信号的缓存触发器之前加两级触发器进行同步处理，来减少亚稳态的传播。

## 21. 低功耗简介

### 21.1. 功耗影响

#### 21.1.1. 便携性

​	功耗越低，同等电量下电子产品工作时间越长，便携性设备的电池容量和体积设计的困难度也会降低。

#### 21.1.2. 性能

​	功耗越大，耗能越多，产生的热量越多，各器件的工作性能就会受到影响。

#### 21.1.3. 成本

​	不考虑低功耗设计时，一个功能的实现方法可能较为繁琐，实现的器件增多，产品面积增大；同时功耗多大时，就要考虑散热装置，这又增加了组装成本。

### 21.2. 功耗类型

​	功耗类型一般可分为动态功耗、静态功耗和浪涌功耗。

#### 21.2.1. 动态功耗

​	动态功耗主要包括开关功耗（或翻转功耗）和短路功耗（或内部功耗）。

##### 开关功耗

​	在 CMOS 数字电路中，对负载电容进行充放电时消耗的功耗为开关功耗。
$$
P = \frac{1}{2} V_{DD}^{2} \cdot C_{load} \cdot T_{r}
$$
​	其中，$V_{DD}$ 为供电电压，$C_{load}$ 为后记电路等效的负载电容，$T_{r}$ 为输入信号的翻转率。

##### 短路功耗

​	信号的翻转不是在瞬间完成的。因此，在输入信号进行翻转时，PMOS 和 NMOS 总有一段时间是同时导通的，那么从电源 $V_{DD}$ 到 地 $V_{SS}$ 之间就有了通路，形成短路电流，产生了短路功耗。
$$
P = V_{DD} \cdot Q \cdot T_{r}
$$
​	其中，$V_{DD}$ 为供电电压，$T_{r}$ 为翻转率，$Q$ 为一次翻转过程中从电源流到地的电荷量。

#### 21.2.2. 静态功耗

​	在 CMOS 电路中，静态功耗主要是漏电流引起的功耗，往往和工艺有关。漏电流的组成主要为：PN 结反向电流、源极和漏极之间的亚阈值电流、栅极漏电流（包括栅极和漏极之间的感应漏电流）、栅极和衬底之间的隧道漏电流。

​	一般情况下，漏电流主要是指栅极泄露电流和亚阈值电流。对于超深亚微米工艺，隧道漏电流称为主要电流之一。

- 漂移电流：PN 结两端加反向电压时，P 区空穴和 N 区电子的运动相反，没有电流通过，二级管处于截止状态，部分能量较大的空穴和电子会挣脱反向电场的束缚而形成微弱的漂移电流；
- 栅极泄露功耗时在栅极加上信号后，栅极到衬底之间存在电容，因此在栅衬之间就会存在电流，会产生功耗；
- 亚阈值电流：栅极电压低于导通阈值，仍会产生从漏极到源极的泄露电流。此电流称为亚阈值电流。在较狭窄的晶体管中，漏极和源极距离较近的情况下会产生亚阈值电流。晶体管越窄，泄露电流越大；
- 隧道漏电流：属于量子力学范畴。

$$
P = V_{DD} \cdot I_{leak}
$$

#### 21.2.3. 浪涌功耗

​	浪涌功耗是浪涌电流引起的功耗。浪涌电流是指开机或者唤醒时，器件流过的最大电流，因此浪涌电流也称为启动电流。

### 21.3. 功耗模型

#### 21.3.1. library 信息

​	部分 library 工艺的代码描述中，包含功耗相关的参数。

#### 21.3.2. cell 信息

​	一个 library 中会有多个基本功能单元，用关键字 cell 声明，也包含了多种功耗信息。

#### 21.3.3. 内部功耗信息

​	cell 定义中，内部功能会以查找表的形式定义。cell 的内部功耗与其转换时间和输出电容负载有关。根据输入转换时间和输出电容的大小，在工艺表中进行查表，得到上升功耗和下降功耗。
$$
P = \frac{1}{2}(rise_power + fall_power) \cdot T_{r}
$$

#### 21.3.4. 静态功耗信息

​	cell 定义中，静态功耗（漏电功耗）会有定义。静态功耗与 cell 的状态有关，也就是输入输出信号在不同的状态下，功耗也会有所差异。通过状态进行查表，就可以得到相应的静态功耗了。

## 22. 系统级低功耗设计

### 22.1. 多电压技术

​	一般来说，电压越低，功耗越低，但是性能往往会越差。综合功耗与性能的考虑，可以对不同的模块采用不同的电压设计。

- 各电压区域有固定的电压；
- 各电压区域的固定电压的选择由软件控制；
- 自适应的方式，各区域的电压可变，称为动态电压条件。

​	一般来说，供电电压越大，电路延迟越小，性能越高。例如，芯片的处理器核、存储器一般需要较高的性能，所以可以采用较高的电压方案；而其他外部设计，可以采用较小的电压方案，来降低功耗。

### 22.2. 系统时钟分配

​	一般来说，频率越高，性能越好，但功耗越大。通过合理的时钟分配，也能有效的降低功耗。

#### 22.2.1. 时钟分频

​	通过时钟分频，各模块采用合理的工作时钟。一般 CPU 总线需要较高的时钟来满足较高的设计需求，而 UART，SPI 等外设工作频率不会很高。

​	将高速时钟进行一定的分频，分别赋予不同的模块。在满足工作性能的条件下看，采用较低的工作时钟频率，可以有效减少功耗。

#### 22.2.2. 工作模块

​	在设计中，加入多种低功耗时钟分配方案，手动选择一种工作模式，可以降低功耗。

| 模式      | 说明                                   |
| --------- | -------------------------------------- |
| Normal    | 主时钟使用较高频率的 PLL 时钟          |
| Slow      | 主时钟使用较低的本地时钟               |
| Low-Power | 总线时钟关闭，只保留一些外设的工作时钟 |
| Sleep     | 时钟全部关闭，全设计进入睡眠状态       |

#### 22.2.3. 自适应选择

​	根据当前的工作状态，自适应的选择合适的工作频率，也可以降低功耗。

### 22.3. 软硬件划分

​	系统中的功耗都是硬件单元消耗的。在设计过程中，可以根据设计规范和自身经验对系统性能进行推测，决定哪一部分使用硬件来实现，哪一部分使用软件来实现，从而到达性能和功耗的最佳平衡。

### 22.4. IP 或单元库选择

​	如今很多设计依赖于 IP 的集成。选择 IP 时，在满足工作性能的条件下，也需要合理的选择功耗相对较低的 IP 。

## 23. RTL 级低功耗设计

### 23.1. 并行与流水

​	对于一个功能模块，可以通过并行的方式实现，也可以通过流水线的方式实现，这两种方法都是用资源换速度。在一定的场合下，灵活的使用这两中方法，可以降低功耗。

#### 23.1.1. 并行处理

​	并行处理，可以同时处理多条执行语句，使执行效率变高。所以在满足工作需求的条件下，采用并行处理，可降低系统工作频率，减少功耗。

#### 23.1.2. 流水线处理

​	流水线设计可以将一个较长的组合路径分为 N 级流水线。路径长度缩短为原始路径长度的 1/N 。此时如果时钟频率不变，则在一个周期内，只需要对电容 C/N 进行充放电，而不是对原来的电容 C 进行充放电。因此在相同的频率要求下，可以采用较低的电源电压来驱动系统，使功耗降低。

### 23.2. 资源共享和状态编码

#### 23.2.1. 资源共享

​	当设计中一些相同的运算逻辑在多处使用时，就可以使用资源共享的方法，避免多个运算逻辑的重复出现，减少资源的消耗。

#### 23.2.2. 状态编码

​	对于一些变化频繁的信号，翻转率相对较高，功耗相对较大。可以利用状态编码的方式来降低开关活动，减少功耗。例如，使用格雷码代替二进制编码，每一时刻只有 1 bit 的数据翻转，翻转率降低，功耗随之降低。

### 23.3. 操作数隔离

​	如果在某一段时间内，数据通路的输出是无用的，将输入置成固定值，数据通路部分没有翻转，功耗就会降低。

​	一般来说，操作数隔离的操作发生在代码综合的时候。这个过程往往是人为可设置、编译器可自动识别的。当然，良好的代码风格，在编写 RTL 电路时，就考虑周全，更加有助于实现操作数的隔离，从而降低功耗。

### 23.4. 门控时钟

​	通常情况下，时钟树由大量的缓冲器和反相器组成。而时钟信号为设计中翻转率最高的信号，时钟树的功耗可高达整个设计功耗 30% 。加入门控（clock gating）电路，可减少时钟树的开关行为，能节省开关功耗。同时，时钟引脚开关行为的减少，寄存器的内部功耗也会减少。所以，采用门控时钟，可以有效地降低功耗。

#### 23.4.1. 实现原理

​	通俗来讲，当模块或触发器不工作时，将时钟关闭而不影响正常功能的逻辑，可以称之为门控时钟逻辑。此时时钟并不是一直存在的，所以可以形象的称之为门控时钟。

##### 使用与逻辑

​	最简单的方法，是直接将时钟使能控制信号与时钟做与逻辑。该方法缺点也非常明显，由于时序或抖动的原因，时钟使能信号与时钟进行与逻辑后，容易产生毛刺，会对数字电路产生严重影响。

​	毛刺的产生会导致遗漏数据或者数据的重复读取，为解决此类问题，需要使用 Latch 结构来消除毛刺。

##### 使用 Latch

​	数字设计中应该避免 Latch 的产生，但 clock gating 是个例外。所以在进行时序分析时，不用关心 clock gating 部分产生的 Latch 。

##### 使用标准单元库

​	虽然使用 Latch 可以解决门控时钟毛刺的出现，但是时序也需要严格的约束。FPGA 或 IC 设计时，综合库中往往会有集成门控逻辑单元。此类门控逻辑单元经过大量的更新迭代和验证，使用起来更加的方便、安全。

​	因此一般情况下，门控时钟的设计也都会直接调用专门的集成门控逻辑单元。调用方式和基本的逻辑门类似，直接例化即可。

#### 23.4.2. 使用方式

​	合理的使用门控时钟逻辑，对电路时钟进行控制，也会有效的减少功耗。

##### 手动 gating

​	增加时钟使能信号，认为的控制模块工作时钟的有无。模块工作时，将使能信号有效，时钟打开；模块空闲时，将使能信号无效，时钟关闭，节省功耗。

##### 自动 gating

​	模块在工作时，可以自动检测自己的工作状态，并输出一个 busy 信号。外部可以通过该指示信号，对模块内部的部分逻辑进行时钟门控，来减少时钟的翻转，达到自动 gating 的控制。

​	与手动 gating 不同的是，这些模块在工作时，会有短暂的空闲状态。自动 gating 就是要在这短暂的空闲状态时间内关闭掉无用的时钟，而不是像手动 gating ，直接关闭掉整个模块的时钟，否则该模块就不能再正常工作。

##### 自动插入 gating

​	当 RTL 设计完成之后，进行逻辑综合时，编译器也会对代码的逻辑进行自动优化，这就包括将一些触发器的时钟端进行 gating 。

## 24. 显示任务

​	Verilog 中主要用以下 4 中系统任务来显示调试信息：`$display` 、`$write` 、`$strobe` 、`$monitor` 。

### 24.1. $display

​	使用方法和 C 语言中的 printf 函数非常相似，可以直接打印字符串，也可以在字符串中指定变量的格式，对相关变量进行打印。

​	如果没有指定变量的显示格式，变量值会根据在字符串的位置显示出来，相当于参与了字符串的连接。默认 `$display` 显示十进制，`$displayb` 、`$displayo` 、`$displayh` 显示格式分别为二进制、八进制和十六进制。

​	类似于 C 语言，也可以使用格式声明变量类型，或者使用转义字符显示特殊字符。

### 24.2. $write

​	使用方法与 `$display` 完全一样，指示前者不会在每次显示信息完毕自动换行，后者会自动换行。当输出后不需要换行时，可以使用显示任务 `$write` 。

### 24.3. $strobe

​	使用方法与 `$display` 一致，但打印信息的时间和 `$display` 有所差异。当多条语句与 `$display` 任务在同一时间内执行时，这些语句和 `$display` 的执行顺序是不确定的，一般按照程序的顺序结构执行。`$strobe` 则是在其他语句执行完毕之后，才执行显示任务。

### 24.4. $monitor

​	为监测任务，用于变量的持续监测。只要变量发生了变化，`$monitor` 就会打印显示出对应的信息。

```verilog
$monitor("Counter change to value %d at the time %t.", cnt, $time);
```

## 25. 文件操作

​	Verilog 提供了很多可以对文件进行操作的系统任务。详见 [文件操作概述](https://www.runoob.com/w3cnote/verilog2-file.html) 。

## 26. 随机数及概率分布

### 26.1. 随机数

​	Verilog 中使用系统任务 `$random(seed)` 产生随机数，seed 为随机数种子。seed 值不同，产生的随机数也不同；如果 seed 相同，产生的随机数也是一样的。可以为 seed 赋初值，也可以忽略 seed 选项，seed 默认初始值为 0 。

​	无论是否赋初值，每产生一次随机数后，seed 值改变，随机数也随之改变。每改变一次 seed 值，当前输出的随机值会改变；但是下一个状态时，随机数的走向又恢复成系统内部产生的随机序列。

​	建议调用系统任务 `$random` 时，不指定 seed 选项，或指定 seed 选项时使用变量传递参数。不建议调用 `$random` 时，将常数项写到 seed 参数处。此时 seed 值被固定，可能只会产生一个随机数。

### 26.2. 概率分布

​	Verilog 提供了许多按一定概率分布产生数据的系统任务。

| 系统任务   | 调用格式                              | 任务描述                            |
| :--------- | :------------------------------------ | :---------------------------------- |
| 均匀分布   | `$dist_uniform(seed, start, end);`    | `start`、`end` 为数据的起始、结尾   |
| 正态分布   | `$dist_normal (seed, mean, std_dev);` | `mean` 为期望值，`std_dev` 为标准差 |
| 泊松分布   | `$dist_poisson(seed, mean);`          | `mean` 为期望 (等于标准差)          |
| 指数分布   | `$dist_exponential(seed , mean);`     | `mean` 为单位时间内事件发生的次数   |
| 卡方分布   | `$dist_chi_square(seed, free_deg);`   | `free_deg` 为自由度                 |
| t 分布     | `$dist_t(seed, free_deg);`            | `free_deg` 为自由度                 |
| 埃尔朗分布 | `$dist_erlang(seed, k_stage, mean);`  | `k_stage` 为阶数，`mean` 为期望     |

## 27.  实数整数转换

### 27.1. 二进制与小数

#### 27.1.1. 小数转为二进制

​	小数部分需要乘以 2 ，然后判断是否大于 1 。

#### 27.1.2. 二进制转为小数

​	需要按位进行以 1/2 为底的指数相乘并累加的运算。

### 27.2. 浮点数

​	定点数是指小数点位置固定不变的数。整数就是一种定点数，因为小数点总在最后一位；浮点数是指小数点的位置不固定的数。

​	为了便于移植，IEEE 提出了 IEEE-754 标准，以此作为浮点数表示格式的统一标准。IEEE-754 从逻辑上采用一个三元组 {S, E, M} 来表示浮点数。

- S ：符号位，0 为正，1 为负；
- E ：指数部分，称为移码，为避免出现正负指数，移码是由阶码加上固定的偏移量得到的；
- M ：尾数，尾数的最高位总为 1 ，但是尾数部分不存储该位数据，只存储小数部分。

### 27.3. 转换函数

| 调用系统任务              | 任务描述                                                     |
| :------------------------ | :----------------------------------------------------------- |
| `$rtoi( real_val )`       | 实数 `real_val` 转换为整数 `int_val`                         |
| `$itor( int_val )`        | 整数 `int_val` 转换为实数 `real_val`                         |
| `$realtobits( real_val )` | 实数转换为多位宽的寄存器向量，寄存器内按照 IEEE-754 标准存储双精度浮点型数据 |
| `$bitstoreal( vec_val )`  | 多位宽的寄存器向量转换为实数                                 |

## 28. 其他系统任务

### 28.1. 仿真控制

| 系统任务 | 调用格式          | 任务描述                            |
| :------- | :---------------- | :---------------------------------- |
| 退出仿真 | `$finish( type )` | 结束仿真                            |
| 暂停仿真 | `$stop( type )`   | 暂停仿真，用法格式与 `$finish` 相同 |

​	参数 `type` 可选择退出仿真时是否打印信息：

- `type=0` ：直接退出不打印；
- `type=1` ：打印仿真时间和该语句所在的位置行信息；
- `type=2` ：打印仿真时间、位置、存储器和 CPU 时间的使用情况。

​	`$finish` 与 `$stop` 都有让仿真停止的功能。区别在于，`$finish` 是结束本次仿真，结束后无论如何也不能再进行；`$stop` 是暂停当前仿真，仿真暂停后通过 Verilog 仿真工具或命令行还可以使仿真继续进行。

### 28.2. 时间格式

| 系统任务                                                     | 说明               |
| ------------------------------------------------------------ | ------------------ |
| `$printtimescale(hierarchy)`                                 | 打印时间单位和精度 |
| `$timeformat(unit_num, precision_num, suffix_string, min_field_width)` | 设置时间单位和精度 |

- `printtimescale` ：按照 TimeScale of  (hierarchy) is 1 (unit) / 1 (precision) 的格式打印信息，hierarchy 为模块访问层次，可省略，此时打印当前模块的 timescale 信息；
- `timeformat` ：
  - `unit_num` ：设置时间单位，默认以 `timescale 为准；
  - `precision_num` ：设置时间单位中小数有效位数，默认为 0 ；
  - `suffix_num` ：设置时间后缀信息， 默认为空；
  - `min_field_width` ：设置时间信息所占的字符节数，默认为 20 。

### 28.3. 仿真时间

| 系统任务    | 说明                               |
| ----------- | ---------------------------------- |
| `$time`     | 返回一个 64 bit 整数型时间值       |
| `$stime`    | 返回一个 32 bit 整数型时间值       |
| `$realtime` | 返回一个实数型时间值，可以是浮点数 |

### 28.4. 命令行传参

​	Verilog 还提供了交互任务 `$test$plusargs(str)` 和 `$value$plusargs` ，仿真时可通过命令行传参的方式进行参数的传递，为仿真调试提供了极大的便利。

| 系统任务                    | 说明                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `$test$plusargs(str)`       | 仿真时，通过命令行传递的字符串数据如果和 str 一致，则返回 1， 否则返回 0 |
| `$value$plusargs(str, var)` | 仿真时，通过命令行传递的字符串数据如果和 str 一致，则返回 1，否则返回 0 ；需要在 str 内部指定传递给 var 变量的类型 |

- 使用 `$test$plusargs(str)` 时，只需要在仿真命令行中加入 `+str` 即可；
- 使用 `$value$plusargs(str, var)` 时，需要在 str 内部指定传递参数时数据的类型；而在命令行传递参数时，数值不需要添加任何有关进制的说明，只保留相关进制的数据即可；命令行传递参数的格式需要参照 str 中声明的格式。

## 29. PLI 简介

​	进行数字设计时，经常会遇到特殊的情况，Verilog 中的任务和函数已经不能满足仿真需求，需要自定义一些系统任务和函数。编程语言结构（Program Language Interface）提供了一套接口子程序，用于访问设计内部的数据结构，并可以提取仿真环境信息。用户可以调用这些子程序，自定义系统任务和系统函数，与设计内部数据以及 Verilog 仿真器环境进行交互。

### 29.1. PLI 功能

​	通俗来讲，Verilog PLI 提供了一套 C 语言函数，设计人员可以调用这些集成函数编写软件 C 程序。RTL 编译时，将编写的软件程序也集成到仿真环境中。仿真运行时，通过系统任务调用的方式，就可以动态的访问仿真中的数据结构。这种访问是双向的，不仅可以从仿真器的数据结构中读取数据，还能修改数据结构的信息。

### 29.1. PLI 使用

​	通过编写系统任务和系统函数，用户能够用 PLI 和 C 程序扩展 Verilog 语言。这些用户定义的系统任务和函数的名称必须以 `$` 开头。此时 Verilog 里面的任务相当于一个子程序。当调用任务时，仿真器的执行流程跳转到子程序，完成任务后执行流程返回。Verilog 任务并不返回数值，但是可以有输入、输出和双向的形参。

​	Verilog 里面的函数跟大多数语言里的函数一样。当调用函数时，它运行一套指令，然后返回一个数值给调用它的指令。

## 30. TF 子程序

​	TF（task/function）子程序主要用于 Verilog 与用户 C 程序边界的两个方向上的数据传输。

## 31. ACC 子程序

​	ACC 子程序主要用于从内部数据结构中读取特定对象的相关信息，并把特定对象的相关信息写入内部数据结构中。

## 32. 逻辑综合

### 32.1. 基本概念

​	综合，就是在标准单元库和特定的设计约束基础上，把数字设计的高层次描述转换为优化的门级网表的过程。标准单元库对应工艺库，可以包含简单的与门、非门等基本逻辑门单元，也可以包含特殊的宏单元。设计约束一般包括时序、负载、面积、功耗等方面的约束。

​	无论是数字芯片设计，还是 FPGA 开发，现在综合过程基本都是借用计算机辅助逻辑综合工具，自动的将高层次描述转换为逻辑门电路。设计人员可以将精力集中在系统结构方案、高层次描述、设计约束和标准工艺库等方面，而不用关心高层次的描述怎么转换为门级电路。综合工具在内部反复进行逻辑转换、优化，最终生成最优的门级电路。

### 32.2. 可综合性设计

​	Verilog 主要用于数字电路设计的描述，但不是所有的描述方式都可以被综合成实际的硬件电路。所以使用 Verilog 设计数字电路时，一定要注意电路的可综合性。testbench 可以随心所欲，只要能构造出需要的仿真激励条件即可。

#### 32.2.1. 可综合结构

|  结构类型  | 关键字                                                       |                             描述                             |
| :--------: | :----------------------------------------------------------- | :----------------------------------------------------------: |
|  端口信号  | `inout` `input` `output`                                     |                      端口信号只有 3 种                       |
|    参数    | `parameter` `localparam`                                     |                             ---                              |
|  信号变量  | `wire` `reg` `tri` `integer`                                 |                             ---                              |
|    模块    | `module`                                                     |                             ---                              |
|  门级原语  | `and` `nand` `or` `nor` `xor` `xnor` `buf` `not` `bufif0` `bufif1` `notif0` `notif1` `supply0` `supply1` |                       直接调用例化即可                       |
|    例化    | ---                                                          |                 支持模块例化、门级原语例化等                 |
| 函数与任务 | `function` `task`                                            |                    支持不含时序结构的表述                    |
|  连续赋值  | `assign`                                                     |                     不支持带有延迟的表述                     |
|  过程赋值  | `always` `begin` `end`                                       |                   可设计时序逻辑或组合逻辑                   |
|  条件语句  | `if` `case` `default`                                        |               条件中不能包含 `z` 或 `x` 的比较               |
|  循环语句  | `for` `while` `forever`                                      | `while` 、`forever` 必须包含 `@(posedge clk)` 或 `@(negedge clk)`，避免组合逻辑回路 |
|  边沿触发  | `negedge` `posedge`                                          |                             ---                              |
|   操作符   | ---                                                          |            支持除 `===` 与 `!==` 以外的所有操作符            |

#### 32.2.2. 不可综合结构

|    结构类型    | 关键字            |                             描述                             |
| :------------: | :---------------- | :----------------------------------------------------------: |
|    变量类型    | `time`            |                    仿真时使用的时间型变量                    |
|    系统任务    | ---               |        大多数系统任务都是辅助仿真，不能综合为实际电路        |
|    过程结构    | `initial`         |  `initial` 常用作仿真时信号赋初值操作，或控制激励信号的时序  |
|    并行语句    | `fork` `join`     | 常用作仿真时并行结构的描述，`always @(posedge clk)` 描述的并行结构可综合 |
|    延迟语句    | `#`               | 所有带延迟标志 `#` 的表述均不可综合，但仿真时电路中会有延时，综合时也不会报错 |
|  电平敏感触发  | `wait`            |                  多用于仿真中信号的检测启动                  |
| 强制赋值和释放 | `force` `release` |        多用于仿真中阻断其他驱动源，对信号进行强制赋值        |

#### 32.2.3. 或可综合结构

|    结构类型    | 关键字                        |                             描述                             |
| :------------: | :---------------------------- | :----------------------------------------------------------: |
|  x/z 条件语句  | `casex` `casez`               |        有些综合工具能识别该语句中的非 `x/z` 比较逻辑         |
| 不同强度的线网 | `wand` `triand` `wor` `trior` | 当信号有多个驱动源时需要使用，但现在数字设计基本摒弃了这些变量类型 |
|    实数变量    | `real`                        |                   往往用于仿真时的精确计算                   |
|    过程终止    | `disable`                     |          终止过程块执行，大多数综合工具不支持该命令          |
|    循环语句    | `repeat` `while` `forever`    | `repeat` 常用作仿真中语句循环执行固定次数 ；`while` 、`forever` 循环次数为常量时也可能可综合 |
| 用户自定义原语 | UDP                           | 其实目前大多数综合工具都支持 UDP 只是某些古老的综合工具不会识别 |
|  过程连续赋值  | `assign` `deassign`           | 综合工具大多不支持该操作下 `reg` 数据类型的综合，支持该操作下 `wire` 数据类型的综合 |

### 32.3. 可综合性建议

​	使用 Verilog 进行数字设计时，可综合的结构可大胆使用，不可综合的结构仿真中使用，有些综合工具支持有些不支持的结构尽量不要使用。

​	除非某些特殊设计，否则设计中不要编写潜在的会被综合成 Latch 的逻辑。

​	变量声明时，不要学 C 语言格式对寄存器变量进行赋初值操作。仿真时变量会有设置的处置，综合后寄存器初值是不确定的。如果信号初值会影响逻辑功能，则仿真过程可能会因验证不充分而错过查找出逻辑错误的机会。

​	所有内部寄存器都应该使用复位进行赋初值操作，以确保系统复位时各寄存器都有稳定的状态。因为没有复位端，综合后电路中寄存器的初始值不能确定，可能会导致功能错误。

​	组合逻辑使用阻塞赋值，时序逻辑使用非阻塞赋值。组合逻辑一般使用连续赋值语句 `assign` 描述，`always` 描述的电路也能被综合成组合逻辑。

​	`always` 语句中被赋值的信号一定要声明为 `reg` 型，在组合逻辑中，该 `reg` 变量会被综合成线网，在时序逻辑中，该 `reg` 变量会被综合成触发器。

​	同一个变量不能受多个时钟（或 `always` 块）控制，也不能受时钟的双边沿控制。此类描述也是不可综合的。

​	避免设计中出现 `x` 或 `z` 值，因为综合工具只能识别 `0` 或 `1` 的逻辑值。